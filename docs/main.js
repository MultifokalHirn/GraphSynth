// Generated by Haxe 4.0.5
(function ($global) { "use strict";
var $estr = function() { return js_Boot.__string_rec(this,''); },$hxEnums = $hxEnums || {},$_;
function $extend(from, fields) {
	var proto = Object.create(from);
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
var HxOverrides = function() { };
HxOverrides.__name__ = true;
HxOverrides.cca = function(s,index) {
	var x = s.charCodeAt(index);
	if(x != x) {
		return undefined;
	}
	return x;
};
HxOverrides.substr = function(s,pos,len) {
	if(len == null) {
		len = s.length;
	} else if(len < 0) {
		if(pos == 0) {
			len = s.length + len;
		} else {
			return "";
		}
	}
	return s.substr(pos,len);
};
HxOverrides.remove = function(a,obj) {
	var i = a.indexOf(obj);
	if(i == -1) {
		return false;
	}
	a.splice(i,1);
	return true;
};
HxOverrides.iter = function(a) {
	return { cur : 0, arr : a, hasNext : function() {
		return this.cur < this.arr.length;
	}, next : function() {
		return this.arr[this.cur++];
	}};
};
Math.__name__ = true;
var Std = function() { };
Std.__name__ = true;
Std.string = function(s) {
	return js_Boot.__string_rec(s,"");
};
var StringTools = function() { };
StringTools.__name__ = true;
StringTools.rpad = function(s,c,l) {
	if(c.length <= 0) {
		return s;
	}
	var buf_b = "";
	buf_b = "" + (s == null ? "null" : "" + s);
	while(buf_b.length < l) buf_b += c == null ? "null" : "" + c;
	return buf_b;
};
var app_Clipboard = function() {
	this.nodeData = null;
};
app_Clipboard.__name__ = true;
app_Clipboard.prototype = {
	copyNode: function(node) {
		this.nodeData = node.serialize(true);
	}
	,hasData: function() {
		return this.nodeData != null;
	}
	,pasteNode: function(graph,atX,atY) {
		graph.createNodeByDataAt(atX,atY,this.nodeData);
	}
	,__class__: app_Clipboard
};
var app_Context = function(canvas,graph,renderer,clipboard) {
	this.canvas = canvas;
	this.graph = graph;
	this.renderer = renderer;
	this.clipboard = clipboard;
};
app_Context.__name__ = true;
app_Context.prototype = {
	changeGraph: function(to) {
		return new app_Context(this.canvas,to,this.renderer,this.clipboard);
	}
	,__class__: app_Context
};
var app_Control = function(context) {
	this.context = context;
};
app_Control.__name__ = true;
app_Control.prototype = {
	onDragBegin: function(x,y,tapCount) {
	}
	,onPressing: function(x,y) {
	}
	,onLongPress: function(x,y,tapCount) {
	}
	,onReleased: function(x,y,tapCount) {
	}
	,step: function(x,y,touching) {
	}
	,get_renderer: function() {
		return this.context.renderer;
	}
	,get_graph: function() {
		return this.context.graph;
	}
	,__class__: app_Control
};
var app_InputSource = $hxEnums["app.InputSource"] = { __ename__ : true, __constructs__ : ["Touch","Mouse"]
	,Touch: {_hx_index:0,__enum__:"app.InputSource",toString:$estr}
	,Mouse: {_hx_index:1,__enum__:"app.InputSource",toString:$estr}
};
var pot_core_App = function(canvas,captureInput) {
	if(captureInput == null) {
		captureInput = true;
	}
	this.canvas = canvas;
	this.pot = new pot_core_Pot(this,canvas);
	if(captureInput) {
		this.input = new pot_input_Input(canvas,this.pot);
	} else {
		this.input = null;
	}
	this.frameCount = 0;
	this.setup();
};
pot_core_App.__name__ = true;
pot_core_App.prototype = {
	setup: function() {
	}
	,loop: function() {
	}
	,__class__: pot_core_App
};
var app_Main = function() {
	this.octaveShift = 4;
	this.prevKeyIndex = -1;
	this.touchingBelow = false;
	this.prevY = 0;
	this.prevX = 0;
	this.menuShowCount = 0;
	this.createNodeMode = false;
	this.continuousPressCount = 0;
	this.beginCanvasY = 0;
	this.beginCanvasX = 0;
	this.beginWorldY = 0;
	this.beginWorldX = 0;
	this.touchId = -1;
	this.pressCount = 0;
	this.ppress = false;
	pot_core_App.call(this,window.document.getElementById("canvas"),true);
};
app_Main.__name__ = true;
app_Main.main = function() {
	new app_Main();
};
app_Main.__super__ = pot_core_App;
app_Main.prototype = $extend(pot_core_App.prototype,{
	setup: function() {
		var _gthis = this;
		this.pixelRatio = window.devicePixelRatio | 0;
		this.pot.sizeMax(this.pixelRatio);
		var width = 0;
		var height = 0;
		var resize = function() {
			var w = _gthis.canvas.parentElement.offsetWidth * _gthis.pixelRatio;
			var h = _gthis.canvas.parentElement.offsetHeight * _gthis.pixelRatio;
			if(width != w || height != h) {
				width = w;
				height = h;
				_gthis.canvas.width = width;
				_gthis.canvas.height = height;
			}
		};
		this.canvas.style.width = null;
		this.canvas.style.height = null;
		window.addEventListener("resize",resize);
		resize();
		this.pot.frameRate(60);
		app_Main.inputForDebug = this.input;
		this.init();
		this.pot.start();
	}
	,init: function() {
		var _gthis = this;
		this.compiler = new app_WebAudioCompiler();
		var doc = window.document;
		var playing = false;
		var toggle = doc.getElementById("toggle");
		toggle.addEventListener("click",function() {
			if(playing) {
				_gthis.compiler.stop();
			} else {
				_gthis.compiler.start();
			}
			playing = !playing;
			if(playing) {
				toggle.classList.remove("highlighted");
				return toggle.innerText = "Mute";
			} else {
				toggle.classList.add("highlighted");
				return toggle.innerText = "Play";
			}
		});
		doc.getElementById("export").addEventListener("click",function() {
			var input = doc.createElement("pre");
			doc.body.appendChild(input);
			var rootGraph = _gthis.control.get_graph();
			while(rootGraph.parent != null) rootGraph = rootGraph.parent;
			input.innerText = JSON.stringify(rootGraph.serialize());
			var sel = doc.getSelection();
			sel.selectAllChildren(input);
			doc.execCommand("copy");
			sel.removeAllRanges();
			doc.body.removeChild(input);
			window.alert("copied!");
			return;
		});
		doc.getElementById("import").addEventListener("click",function() {
			var text = window.prompt("paste saved text");
			if(text == null || text == "") {
				return;
			}
			try {
				var data = JSON.parse(text);
				var rootGraph1 = _gthis.control.get_graph();
				while(rootGraph1.parent != null) rootGraph1 = rootGraph1.parent;
				var nextGraph = graph_Graph.deserialize(data,rootGraph1.listener);
				rootGraph1.destroyEverything();
				_gthis.control.get_renderer().view.centerX = 0;
				_gthis.control.get_renderer().view.centerY = 0;
				_gthis.control.nextControl = new app_MainControl(_gthis.control.context.changeGraph(nextGraph));
			} catch( e ) {
				window.alert(Std.string("couldn't load: " + Std.string(((e) instanceof js__$Boot_HaxeError) ? e.val : e)));
			}
			return;
		});
		doc.getElementById("up").addEventListener("click",function() {
			_gthis.octaveShift++;
			_gthis.prevKeyIndex = -1;
			if(_gthis.octaveShift > 8) {
				_gthis.octaveShift = 8;
			}
			return;
		});
		doc.getElementById("down").addEventListener("click",function() {
			_gthis.octaveShift--;
			_gthis.prevKeyIndex = -1;
			if(_gthis.octaveShift < 1) {
				_gthis.octaveShift = 1;
			}
			return;
		});
		var graph1 = new graph_Graph(this.compiler);
		app_NodeList.OUTPUT.create(graph1,0,0);
		this.renderer = new render_Renderer(this.canvas);
		this.renderer.view.scale = (1 + (this.pixelRatio - 1) * 0.8) * 1.6;
		this.control = new app_MainControl(new app_Context(this.canvas,graph1,this.renderer,new app_Clipboard()));
	}
	,loop: function() {
		var x = this.prevX;
		var y = this.prevY;
		var press = false;
		var hasTouchInput = false;
		if(this.touchId == -1 && this.input.touches.touches.length > 0) {
			this.touchId = this.input.touches.touches[0].id;
		}
		var _g = 0;
		var _g1 = this.input.touches;
		while(_g < _g1.touches.length) {
			var t = _g1.touches[_g];
			++_g;
			if(t.id != this.touchId) {
				continue;
			}
			hasTouchInput = true;
			press = t.touching;
			x = t.x;
			y = t.y;
			this.control.lastInputSource = app_InputSource.Touch;
		}
		if(!hasTouchInput) {
			this.touchId = -1;
			press = this.input.mouse.left;
			if(press || this.input.mouse.dx != 0 || this.input.mouse.dy != 0) {
				x = this.input.mouse.x;
				y = this.input.mouse.y;
				this.control.lastInputSource = app_InputSource.Mouse;
			}
		}
		var _this = this.renderer;
		var gx = (x - _this.canvas.width * 0.5) / _this.view.scale + _this.view.centerX;
		var _this1 = this.renderer;
		var gy = (y - _this1.canvas.height * _this1.canvasCenterHeightRatio) / _this1.view.scale + _this1.view.centerY;
		if(!this.ppress && press && y > this.canvas.height * 0.8) {
			this.touchingBelow = true;
			this.compiler.attack();
		}
		if(!press) {
			if(this.touchingBelow) {
				this.compiler.release();
			}
			this.touchingBelow = false;
		}
		if(!this.ppress && press && !this.touchingBelow) {
			this.prevPressFrame = this.pressFrame;
			this.pressFrame = this.frameCount;
			var dx = this.beginCanvasX - x;
			var dy = this.beginCanvasY - y;
			if(dx * dx + dy * dy > app_UISetting.dragBeginThreshold * app_UISetting.dragBeginThreshold) {
				this.continuousPressCount = 0;
			}
			if(this.frameCount > this.prevPressFrame + app_UISetting.longPressTimeThreshold) {
				this.continuousPressCount = 0;
			}
			this.continuousPressCount++;
			this.beginCanvasX = x;
			this.beginCanvasY = y;
			var _this2 = this.renderer;
			this.beginWorldX = (this.beginCanvasX - _this2.canvas.width * 0.5) / _this2.view.scale + _this2.view.centerX;
			var _this3 = this.renderer;
			this.beginWorldY = (this.beginCanvasY - _this3.canvas.height * _this3.canvasCenterHeightRatio) / _this3.view.scale + _this3.view.centerY;
		}
		if(press || this.ppress) {
			this.pressCount++;
		} else {
			this.pressCount = 0;
			this.dragging = null;
			this.cableFrom = null;
		}
		if(!press && this.ppress && !this.touchingBelow) {
			this.control.onReleased(gx,gy,this.continuousPressCount);
		}
		if(press && this.pressCount < app_UISetting.longPressTimeThreshold && !this.touchingBelow) {
			var dx1 = this.beginCanvasX - x;
			var dy1 = this.beginCanvasY - y;
			if(dx1 * dx1 + dy1 * dy1 > app_UISetting.dragBeginThreshold * app_UISetting.dragBeginThreshold) {
				this.control.onDragBegin(this.beginWorldX,this.beginWorldY,this.continuousPressCount);
				this.continuousPressCount = 0;
				this.pressCount = 100;
			}
		}
		if(press && this.pressCount == app_UISetting.longPressTimeThreshold && !this.touchingBelow) {
			this.control.onLongPress(this.beginWorldX,this.beginWorldY,this.continuousPressCount);
			this.continuousPressCount = 0;
		}
		if(press && this.ppress && !this.touchingBelow) {
			this.control.onPressing(gx,gy);
		}
		this.control.step(gx,gy,press && this.ppress && !this.touchingBelow);
		this.renderer.c2d.fillStyle = "rgba(" + (229.5 | 0) + "," + (229.5 | 0) + "," + (229.5 | 0) + "," + 1.0 + ")";
		this.renderer.context().fillRect(0,this.canvas.height * 0.8,this.canvas.width,this.canvas.height * 0.2);
		var keyIndex = this.renderer.renderKeyboard(0,this.canvas.height * 0.8,this.canvas.width,this.canvas.height * 0.2,"C" + this.octaveShift,x,y,press);
		if(keyIndex != -1 && keyIndex != this.prevKeyIndex && press) {
			var time = 0.001;
			if(!this.ppress) {
				time = 0;
			}
			this.prevKeyIndex = keyIndex;
			this.compiler.setFrequency(440 * Math.pow(2,this.octaveShift - 4 + (keyIndex - 9) / 12),time);
		}
		this.renderer.renderTouch(x,y,press && this.ppress);
		if(this.control.nextControl != null) {
			this.control = this.control.nextControl;
		}
		this.ppress = press;
		this.prevX = x;
		this.prevY = y;
	}
	,__class__: app_Main
});
var app_MainControl = function(context) {
	app_Control.call(this,context);
	this.pickRadius = app_UISetting.tapErrorThreshold / this.get_renderer().view.scale;
	this.panTargetX = this.get_renderer().view.centerX;
	this.panTargetY = this.get_renderer().view.centerY;
};
app_MainControl.__name__ = true;
app_MainControl.__super__ = app_Control;
app_MainControl.prototype = $extend(app_Control.prototype,{
	centering: function() {
		this.panTargetX = 0;
		this.panTargetY = 0;
		var bv = this.get_graph().computeBoundingVolume();
		this.get_renderer().view.centerX -= bv.x;
		this.get_renderer().view.centerY -= bv.y;
		var _g = 0;
		var _g1 = this.get_graph().vertices;
		while(_g < _g1.length) {
			var v = _g1[_g];
			++_g;
			v.point.x -= bv.x;
			v.point.y -= bv.y;
		}
	}
	,makeNode: function(info) {
		var n = this.get_graph().createNode((Math.random() * 2 - 1) * 10,50 + (Math.random() * 2 - 1) * 10,info.type,new graph_NodeSetting(info.labelName,info.role));
		var _g = 0;
		var _g1 = info.inParams;
		while(_g < _g1.length) n.createSocket(graph_SocketType.Param(false,_g1[_g++]));
		var _g2 = 0;
		var _g3 = info.outParams;
		while(_g2 < _g3.length) n.createSocket(graph_SocketType.Param(true,_g3[_g2++]));
		var np = n.phys;
		var tmp = Math.random() * 8;
		np.vertex.point.vx = tmp - 4;
		var tmp1 = Math.random() * 8;
		np.vertex.point.vy = tmp1 - 4;
		var _g4 = 0;
		var _g5 = n.sockets;
		while(_g4 < _g5.length) {
			var sp = _g5[_g4++].phys;
			sp.vertex.point.vx = np.vertex.point.vx;
			sp.vertex.point.vy = np.vertex.point.vy;
		}
		return n;
	}
	,onDragBegin: function(x,y,tapCount) {
		if(tapCount == 1) {
			this.dragging = this.get_graph().pick(x,y,3 | (16 | 32),this.pickRadius);
			if(this.dragging == null) {
				var _this = this.get_renderer();
				this.beginCanvasX = (x - _this.view.centerX) * _this.view.scale + _this.canvas.width * 0.5;
				var _this1 = this.get_renderer();
				this.beginCanvasY = (y - _this1.view.centerY) * _this1.view.scale + _this1.canvas.height * _this1.canvasCenterHeightRatio;
				this.beginCenterX = this.panTargetX;
				this.beginCenterY = this.panTargetY;
				this.panning = true;
			}
			console.log("src/app/MainControl.hx:73:","drag");
		} else if(tapCount == 2) {
			var v = this.get_graph().pick(x,y,3 | (4 | 8 | (16 | 32)),this.pickRadius);
			this.cableFrom = v;
			console.log("src/app/MainControl.hx:77:","from " + Std.string(v != null));
		}
	}
	,onPressing: function(x,y) {
		if(this.panning) {
			var _this = this.get_renderer();
			this.panTargetX = this.beginCenterX - ((x - _this.view.centerX) * _this.view.scale + _this.canvas.width * 0.5 - this.beginCanvasX) / this.get_renderer().view.scale;
			var _this1 = this.get_renderer();
			this.panTargetY = this.beginCenterY - ((y - _this1.view.centerY) * _this1.view.scale + _this1.canvas.height * _this1.canvasCenterHeightRatio - this.beginCanvasY) / this.get_renderer().view.scale;
		}
		if(this.dragging != null) {
			var dvx = (x - this.dragging.point.x) * 0.05;
			var dvy = (y - this.dragging.point.y) * 0.05;
			this.dragging.point.vx += dvx;
			this.dragging.point.vy += dvy;
			var _g = this.dragging.type;
			if(_g._hx_index == 0) {
				var _g1 = 0;
				var _g11 = _g.n.sockets;
				while(_g1 < _g11.length) {
					var sp = _g11[_g1++].phys;
					sp.vertex.point.vx += dvx;
					sp.vertex.point.vy += dvy;
				}
			}
		}
	}
	,onLongPress: function(x,y,tapCount) {
		if(tapCount == 1) {
			var v = this.get_graph().pick(x,y,1 | (16 | 32),this.pickRadius);
			if(v == null) {
				this.nextControl = new app_MainMenuControl(this.context,x,y);
			}
			if(v != null) {
				var _g = v.type;
				if(_g._hx_index == 0) {
					var _g1 = _g.n;
					var _g2 = _g1.setting.role;
					switch(_g2._hx_index) {
					case 7:
						this.nextControl = app_NumberEditControl.createValueEdit(this.context,_g1,_g2.num);
						break;
					case 8:
						switch(_g2.type) {
						case 0:
							_g1.setting.name = "×";
							_g1.setting.role = synth_NodeRole.BinOp(1);
							_g1.notifyUpdate();
							break;
						case 1:
							_g1.setting.name = "+";
							_g1.setting.role = synth_NodeRole.BinOp(0);
							_g1.notifyUpdate();
							break;
						default:
							this.nextControl = new app_NodeEditControl(this.context,_g1);
						}
						break;
					default:
						this.nextControl = new app_NodeEditControl(this.context,_g1);
					}
				}
			}
		}
	}
	,onReleased: function(x,y,tapCount) {
		this.dragging = null;
		this.panning = false;
		if(tapCount == 2) {
			var v = this.get_graph().pick(x,y,1 | 2,this.pickRadius);
			if(v != null && v.type == graph_VertexType.Normal) {
				var _g = 0;
				var _g1 = v.edges;
				while(_g < _g1.length) {
					var e = _g1[_g];
					++_g;
					var v2 = v != e.v1 ? e.v1 : e.v2;
					if(v2.type == graph_VertexType.Normal) {
						v2.vibrate(true);
					}
				}
				this.get_graph().destroyVertex(v);
			}
			console.log("src/app/MainControl.hx:147:","destroy");
		}
		if(this.cableFrom != null) {
			console.log("src/app/MainControl.hx:150:","connect");
			var v1 = this.get_graph().pick(x,y,3 | (16 | 32),this.pickRadius);
			if(v1 != null && this.get_graph().isConnectable(this.cableFrom,v1)) {
				if(this.cableFrom.type == graph_VertexType.Normal) {
					var node = this.makeNode(app_NodeList.DUPL);
					var np = node.phys;
					np.vertex.point.x = this.cableFrom.point.x;
					np.vertex.point.y = this.cableFrom.point.y;
					np.vertex.point.vx = 0;
					np.vertex.point.vy = 0;
					this.get_graph().insertNode(this.cableFrom,node);
					var sp = node.createSocket(graph_SocketType.Normal(true)).phys;
					sp.lookAt(v1.point.x,v1.point.y);
					this.cableFrom = sp.vertex;
				}
				if(v1.type == graph_VertexType.Normal) {
					var node1;
					var _g2 = this.cableFrom.type;
					if(_g2._hx_index == 0) {
						switch(_g2.n.setting.role._hx_index) {
						case 6:
							node1 = true;
							break;
						case 7:
							node1 = true;
							break;
						default:
							node1 = false;
						}
					} else {
						node1 = false;
					}
					var node2 = this.makeNode(node1 ? app_NodeList.MULT : app_NodeList.ADD);
					var np1 = node2.phys;
					np1.vertex.point.x = v1.point.x;
					np1.vertex.point.y = v1.point.y;
					np1.vertex.point.vx = 0;
					np1.vertex.point.vy = 0;
					this.get_graph().insertNode(v1,node2);
					var sp1 = node2.createSocket(graph_SocketType.Normal(false)).phys;
					sp1.lookAt(this.cableFrom.point.x,this.cableFrom.point.y);
					v1 = sp1.vertex;
				}
				if(!this.get_graph().connectVertices(this.cableFrom,v1)) {
					console.log("src/app/MainControl.hx:181:","couldn't connect :(");
				}
			}
			this.cableFrom = null;
		}
	}
	,step: function(x,y,touching) {
		this.get_renderer().view.centerX += (this.panTargetX - this.get_renderer().view.centerX) * 0.2;
		this.get_renderer().view.centerY += (this.panTargetY - this.get_renderer().view.centerY) * 0.2;
		this.get_graph().stepPhysics();
		this.get_renderer().render(this.get_graph());
	}
	,__class__: app_MainControl
});
var app_MenuControl = function(context) {
	app_Control.call(this,context);
	this.count = 0;
	this.firstX = 0;
	this.firstY = 0;
	this.focus = -1;
	this.enabled = false;
};
app_MenuControl.__name__ = true;
app_MenuControl.__super__ = app_Control;
app_MenuControl.prototype = $extend(app_Control.prototype,{
	step: function(x,y,touching) {
		if(this.count == 0) {
			this.firstX = x;
			this.firstY = y;
		}
		var dx = x - this.firstX;
		var dy = y - this.firstY;
		var r = app_UISetting.dragBeginThreshold / this.get_renderer().view.scale;
		if(dx * dx + dy * dy > r * r) {
			this.enabled = true;
		}
		if(!touching) {
			this.enabled = true;
		}
		this.count++;
		this.get_graph().stepPhysics();
		this.get_renderer().render(this.get_graph());
		var menuX = x;
		var menuY = y;
		if(this.lastInputSource == app_InputSource.Touch && !touching || !this.enabled) {
			menuX = 1e6;
			menuY = 1e6;
		}
		this.focus = this.get_renderer().renderMenu(this.menu,this.count / 20,menuX,menuY);
	}
	,__class__: app_MenuControl
});
var app_MainMenuControl = function(context,atX,atY) {
	app_MenuControl.call(this,context);
	this.atX = atX;
	this.atY = atY;
	var nodes2 = [[app_NodeList.OSCILLATOR],[app_NodeList.DELAY],[app_NodeList.FILTER],[app_NodeList.COMPRESSOR],[app_NodeList.FREQUENCY],[app_NodeList.ENVELOPE],[app_NodeList.NUMBER]];
	var _g = [];
	var e = HxOverrides.iter(nodes2);
	while(e.hasNext()) {
		var x = $getIterator(e.next());
		while(x.hasNext()) _g.push(x.next());
	}
	this.nodes = _g;
	if(this.get_graph().parent != null) {
		HxOverrides.remove(this.nodes,app_NodeList.OUTPUT);
	}
	var result = new Array(nodes2.length);
	var _g1 = 0;
	var _g11 = nodes2.length;
	while(_g1 < _g11) {
		var i = _g1++;
		var nodes = nodes2[i];
		var result1 = new Array(nodes.length);
		var _g2 = 0;
		var _g12 = nodes.length;
		while(_g2 < _g12) {
			var i1 = _g2++;
			var n = nodes[i1];
			result1[i1] = n == null ? null : "add " + n.fullName;
		}
		result[i] = result1;
	}
	this.menu = new app_Menu("Menu",result);
	if(context.clipboard.hasData()) {
		this.menu.items.push(["paste"]);
	}
	this.menu.items.push([]);
	this.menu.items.push(["create module"]);
	if(this.get_graph().parent != null) {
		this.menu.items.push(["exit module"]);
	}
	this.menu.items.push(["reset view"]);
	this.menu.items.push(["close"]);
	var _g3 = [];
	var e1 = $getIterator(this.menu.items);
	while(e1.hasNext()) {
		var x1 = $getIterator(e1.next());
		while(x1.hasNext()) _g3.push(x1.next());
	}
	this.flatItems = _g3;
};
app_MainMenuControl.__name__ = true;
app_MainMenuControl.__super__ = app_MenuControl;
app_MainMenuControl.prototype = $extend(app_MenuControl.prototype,{
	onReleased: function(x,y,tapCount) {
		if(this.focus != -1) {
			if(this.flatItems[this.focus] == "reset view") {
				var main = new app_MainControl(this.context);
				main.centering();
				this.nextControl = main;
				return;
			}
			if(this.flatItems[this.focus] == "close") {
				this.nextControl = new app_MainControl(this.context);
				return;
			}
			if(this.flatItems[this.focus] == "exit module") {
				this.get_graph().bakeView(this.get_renderer().view);
				this.nextControl = new app_MainControl(this.context.changeGraph(this.get_graph().parent));
				return;
			}
			if(this.flatItems[this.focus] == "paste") {
				this.context.clipboard.pasteNode(this.get_graph(),this.atX,this.atY);
				this.nextControl = new app_MainControl(this.context);
				return;
			}
			if(this.flatItems[this.focus] == "create module") {
				this.nextControl = new app_SelectNodesControl(this.context);
				return;
			}
			var node = this.nodes[this.focus].create(this.get_graph(),this.atX,this.atY);
			var _g = node.setting.role;
			this.nextControl = _g._hx_index == 7 ? app_NumberEditControl.createValueEdit(this.context,node,_g.num) : new app_MainControl(this.context);
		}
	}
	,__class__: app_MainMenuControl
});
var app_Menu = function(title,items) {
	this.items = [];
	this.title = title;
	this.items = items;
};
app_Menu.__name__ = true;
app_Menu.prototype = {
	__class__: app_Menu
};
var app_ModuleCreationConfirmMenu = function(context) {
	app_MenuControl.call(this,context);
	this.menu = new app_Menu("Menu",[["create module"],["abort grouping"],["end"]]);
};
app_ModuleCreationConfirmMenu.__name__ = true;
app_ModuleCreationConfirmMenu.__super__ = app_MenuControl;
app_ModuleCreationConfirmMenu.prototype = $extend(app_MenuControl.prototype,{
	onReleased: function(x,y,tapCount) {
		if(this.focus != -1) {
			if(this.menu.items[this.focus][0] == "abort grouping") {
				var _g = 0;
				var _g1 = this.get_graph().nodes;
				while(_g < _g1.length) {
					var n = _g1[_g];
					++_g;
					n.selected = false;
					n.selectingCount = 0;
				}
				this.nextControl = new app_MainControl(this.context);
				return;
			}
			if(this.menu.items[this.focus][0] == "end") {
				this.nextControl = new app_SelectNodesControl(this.context);
				return;
			}
			if(this.menu.items[this.focus][0] == "create module") {
				var nodes = [];
				var _g2 = 0;
				var _g11 = this.get_graph().nodes;
				while(_g2 < _g11.length) {
					var n1 = _g11[_g2];
					++_g2;
					if(n1.selected) {
						nodes.push(n1);
						n1.selected = false;
						n1.selectingCount = 0;
					}
				}
				if(nodes.length != 0) {
					this.get_graph().createModule(nodes);
				}
				this.nextControl = new app_MainControl(this.context);
				return;
			}
		}
	}
	,__class__: app_ModuleCreationConfirmMenu
});
var app_NameEditControl = function(context,node,title,initialValue,maxLength,onChange,getNextControl) {
	app_MenuControl.call(this,context);
	this.node = node;
	this.title = title;
	this.maxLength = maxLength;
	this.onChange = onChange;
	this.getNextControl = getNextControl;
	this.menu = new app_Menu(title,[["a","b","c","d","e"],["f","g","h","i","j"],["k","l","m","n","o"],["p","q","r","s","t"],["u","v","w","x","y"],["z",".","+","-","'"],["0","1","2","3","4"],["5","6","7","8","9"],["A/a","BackSpace"]]);
	this.shiftPressed = false;
	this.menu.items.push(["close"]);
	this.name = initialValue;
};
app_NameEditControl.__name__ = true;
app_NameEditControl.createNodeNameEdit = function(context,node,next) {
	var tmp = next != null ? next : function() {
		return new app_NodeEditControl(context,node);
	};
	return new app_NameEditControl(context,node,"Name",node.setting.name,6,function(n) {
		return node.setting.name = n;
	},tmp);
};
app_NameEditControl.__super__ = app_MenuControl;
app_NameEditControl.prototype = $extend(app_MenuControl.prototype,{
	onReleased: function(x,y,tapCount) {
		var _gthis = this;
		if(this.focus != -1) {
			if(this.focus < "abcdefghijklmnopqrstuvwxyz.+-'0123456789SB".length) {
				var command = "abcdefghijklmnopqrstuvwxyz.+-'0123456789SB".charAt(this.focus);
				if(command == "S") {
					this.shiftPressed = !this.shiftPressed;
					var _this = this.menu.items;
					var result = new Array(_this.length);
					var _g = 0;
					var _g1 = _this.length;
					while(_g < _g1) {
						var i = _g++;
						var row = _this[i];
						var result1 = new Array(row.length);
						var _g2 = 0;
						var _g11 = row.length;
						while(_g2 < _g11) {
							var i1 = _g2++;
							var s = row[i1];
							result1[i1] = s.length == 1 ? _gthis.shiftPressed ? s.toUpperCase() : s.toLowerCase() : s;
						}
						result[i] = result1;
					}
					this.menu.items = result;
				} else if(command == "B") {
					if(this.name.length > 0) {
						this.name = HxOverrides.substr(this.name,0,-1);
						this.onChange(this.name);
						if(this.node != null) {
							this.node.notifyUpdate();
						}
					}
				} else {
					if(this.name.length >= this.maxLength) {
						this.name = HxOverrides.substr(this.name,0,this.maxLength - 1);
					}
					var s1 = "abcdefghijklmnopqrstuvwxyz.+-'0123456789SB".charAt(this.focus);
					this.name += _gthis.shiftPressed ? s1.toUpperCase() : s1.toLowerCase();
					this.onChange(this.name);
					if(this.node != null) {
						this.node.notifyUpdate();
					}
				}
			} else {
				this.nextControl = this.getNextControl();
			}
		}
	}
	,step: function(x,y,touching) {
		this.menu.title = this.title + ":" + this.name;
		app_MenuControl.prototype.step.call(this,x,y,touching);
	}
	,__class__: app_NameEditControl
});
var app__$NodeEditControl_Action = $hxEnums["app._NodeEditControl.Action"] = { __ename__ : true, __constructs__ : ["LookInside","Decompose","EditVal","EditName","EditBoundaryName","EditA","EditD","EditS","EditR","Remove","Copy","None"]
	,LookInside: ($_=function(g) { return {_hx_index:0,g:g,__enum__:"app._NodeEditControl.Action",toString:$estr}; },$_.__params__ = ["g"],$_)
	,Decompose: {_hx_index:1,__enum__:"app._NodeEditControl.Action",toString:$estr}
	,EditVal: ($_=function(num) { return {_hx_index:2,num:num,__enum__:"app._NodeEditControl.Action",toString:$estr}; },$_.__params__ = ["num"],$_)
	,EditName: {_hx_index:3,__enum__:"app._NodeEditControl.Action",toString:$estr}
	,EditBoundaryName: ($_=function(boundary) { return {_hx_index:4,boundary:boundary,__enum__:"app._NodeEditControl.Action",toString:$estr}; },$_.__params__ = ["boundary"],$_)
	,EditA: ($_=function(env) { return {_hx_index:5,env:env,__enum__:"app._NodeEditControl.Action",toString:$estr}; },$_.__params__ = ["env"],$_)
	,EditD: ($_=function(env) { return {_hx_index:6,env:env,__enum__:"app._NodeEditControl.Action",toString:$estr}; },$_.__params__ = ["env"],$_)
	,EditS: ($_=function(env) { return {_hx_index:7,env:env,__enum__:"app._NodeEditControl.Action",toString:$estr}; },$_.__params__ = ["env"],$_)
	,EditR: ($_=function(env) { return {_hx_index:8,env:env,__enum__:"app._NodeEditControl.Action",toString:$estr}; },$_.__params__ = ["env"],$_)
	,Remove: {_hx_index:9,__enum__:"app._NodeEditControl.Action",toString:$estr}
	,Copy: {_hx_index:10,__enum__:"app._NodeEditControl.Action",toString:$estr}
	,None: {_hx_index:11,__enum__:"app._NodeEditControl.Action",toString:$estr}
};
var app_NodeEditControl = function(context,node) {
	var _gthis = this;
	app_MenuControl.call(this,context);
	this.node = node;
	var options = [];
	if(node.type._hx_index == 1) {
		options.push(new graph_NodeOption(function(_) {
			return "look inside";
		},function(_1) {
			return _gthis.action = app__$NodeEditControl_Action.LookInside(node.moduleGraph);
		},true));
		options.push(new graph_NodeOption(function(_2) {
			return "edit name:" + node.setting.name;
		},function(_3) {
			return _gthis.action = app__$NodeEditControl_Action.EditName;
		}));
		var _g3 = 0;
		var _g4 = node.moduleBoundaries;
		while(_g3 < _g4.length) {
			var boundary = [_g4[_g3]];
			++_g3;
			options.push(new graph_NodeOption((function(boundary1) {
				return function(_4) {
					return "edit param name:" + boundary1[0].setting.name;
				};
			})(boundary),(function(boundary2) {
				return function(_5) {
					return _gthis.action = app__$NodeEditControl_Action.EditBoundaryName(boundary2[0]);
				};
			})(boundary)));
		}
		options.push(new graph_NodeOption(function(_6) {
			return "decompose";
		},function(_7) {
			return _gthis.action = app__$NodeEditControl_Action.Decompose;
		},true));
		options.push(null);
	}
	if(node.type._hx_index == 3) {
		options.push(new graph_NodeOption(function(_8) {
			return "edit name:" + node.setting.name;
		},function(_9) {
			return _gthis.action = app__$NodeEditControl_Action.EditName;
		}));
		options.push(null);
	}
	var _g5 = node.setting.role;
	switch(_g5._hx_index) {
	case 1:
		var _this = ["sine","sawtooth","square","triangle"];
		var result = new Array(_this.length);
		var _g = 0;
		var _g1 = _this.length;
		while(_g < _g1) {
			var i = _g++;
			result[i] = _this[i] + " wave";
		}
		var items = result;
		var names = ["sin","saw","sq","tri"];
		var types = ["sin","saw","sq","tri"];
		var _g51 = 0;
		var _g6 = items.length;
		while(_g51 < _g6) {
			var i1 = [_g51++];
			options.push(new graph_NodeOption((function(i2) {
				return function(_10) {
					return items[i2[0]];
				};
			})(i1),(function(i3) {
				return function(n) {
					n.name = names[i3[0]];
					return n.role = synth_NodeRole.Oscillator(types[i3[0]]);
				};
			})(i1)));
		}
		options.push(null);
		break;
	case 4:
		var _this1 = ["low pass","high pass","band pass","band stop","low shelf","high shelf","peak"];
		var result1 = new Array(_this1.length);
		var _g2 = 0;
		var _g11 = _this1.length;
		while(_g2 < _g11) {
			var i4 = _g2++;
			result1[i4] = _this1[i4] + " filter";
		}
		var items1 = result1;
		var names1 = ["LPF","HPF","BPF","BSF","LSF","HSF","PF"];
		var types1 = ["lp","hp","bp","bs","ls","hs","p"];
		var _g52 = 0;
		var _g61 = items1.length;
		while(_g52 < _g61) {
			var i5 = [_g52++];
			options.push(new graph_NodeOption((function(i6) {
				return function(_11) {
					return items1[i6[0]];
				};
			})(i5),(function(i7) {
				return function(n1) {
					n1.name = names1[i7[0]];
					return n1.role = synth_NodeRole.Filter(types1[i7[0]]);
				};
			})(i5)));
		}
		options.push(null);
		break;
	case 6:
		var env = _g5.env;
		options.push(new graph_NodeOption(function(_12) {
			return "edit Attack:" + env.a;
		},function(_13) {
			return _gthis.action = app__$NodeEditControl_Action.EditA(env);
		}));
		options.push(new graph_NodeOption(function(_14) {
			return "edit Decay:" + env.d;
		},function(_15) {
			return _gthis.action = app__$NodeEditControl_Action.EditD(env);
		}));
		options.push(new graph_NodeOption(function(_16) {
			return "edit Sustain:" + env.s;
		},function(_17) {
			return _gthis.action = app__$NodeEditControl_Action.EditS(env);
		}));
		options.push(new graph_NodeOption(function(_18) {
			return "edit Release:" + env.r;
		},function(_19) {
			return _gthis.action = app__$NodeEditControl_Action.EditR(env);
		}));
		options.push(null);
		break;
	case 7:
		var num = _g5.num;
		options.push(new graph_NodeOption(function(_20) {
			return "edit value";
		},function(_21) {
			return _gthis.action = app__$NodeEditControl_Action.EditVal(num);
		}));
		options.push(null);
		break;
	default:
	}
	if(node.type._hx_index != 3 && node.setting.role._hx_index != 2) {
		options.push(new graph_NodeOption(function(_22) {
			return "remove";
		},function(_23) {
			return _gthis.action = app__$NodeEditControl_Action.Remove;
		},true));
		options.push(new graph_NodeOption(function(_24) {
			return "copy";
		},function(_25) {
			return _gthis.action = app__$NodeEditControl_Action.Copy;
		},true));
	}
	options.push(new graph_NodeOption(function(_26) {
		return "close";
	},function(_27) {
		return _gthis.action = app__$NodeEditControl_Action.None;
	},true));
	var result2 = new Array(options.length);
	var _g7 = 0;
	var _g12 = options.length;
	while(_g7 < _g12) {
		var i8 = _g7++;
		result2[i8] = options[i8] == null ? [] : [""];
	}
	this.menu = new app_Menu("Edit Node",result2);
	var _g8 = [];
	var _g13 = 0;
	while(_g13 < options.length) {
		var v = options[_g13];
		++_g13;
		if(v != null) {
			_g8.push(v);
		}
	}
	this.options = _g8;
	this.action = app__$NodeEditControl_Action.None;
};
app_NodeEditControl.__name__ = true;
app_NodeEditControl.__super__ = app_MenuControl;
app_NodeEditControl.prototype = $extend(app_MenuControl.prototype,{
	newControl: function() {
		return new app_NodeEditControl(this.context,this.node);
	}
	,onReleased: function(x,y,tapCount) {
		if(this.focus != -1) {
			var option = this.options[this.focus];
			option.onSelected(this.node);
			var _g = this.action;
			switch(_g._hx_index) {
			case 0:
				this.get_graph().bakeView(this.get_renderer().view);
				this.nextControl = new app_MainControl(this.context.changeGraph(_g.g));
				break;
			case 1:
				this.get_graph().decomposeModule(this.node);
				break;
			case 2:
				this.nextControl = app_NumberEditControl.createValueEdit(this.context,this.node,_g.num);
				break;
			case 3:
				this.nextControl = app_NameEditControl.createNodeNameEdit(this.context,this.node);
				break;
			case 4:
				this.nextControl = app_NameEditControl.createNodeNameEdit(this.context,_g.boundary,$bind(this,this.newControl));
				break;
			case 5:
				this.nextControl = app_NumberEditControl.createAttackEdit(this.context,this.node,_g.env);
				break;
			case 6:
				this.nextControl = app_NumberEditControl.createDecayEdit(this.context,this.node,_g.env);
				break;
			case 7:
				this.nextControl = app_NumberEditControl.createSustainEdit(this.context,this.node,_g.env);
				break;
			case 8:
				this.nextControl = app_NumberEditControl.createReleaseEdit(this.context,this.node,_g.env);
				break;
			case 9:
				this.get_graph().destroyNode(this.node);
				break;
			case 10:
				this.context.clipboard.copyNode(this.node);
				break;
			case 11:
				break;
			}
			if(this.nextControl == null && option.closeAfterSelection) {
				this.nextControl = new app_MainControl(this.context);
			}
		}
	}
	,step: function(x,y,touching) {
		var _g = this.node.setting.role;
		this.menu.title = "Edit Node:" + (_g._hx_index == 7 ? Std.string(_g.num.get_value()) : this.node.setting.name);
		var idx = 0;
		var _g2 = 0;
		var _g3 = this.options;
		while(_g2 < _g3.length) {
			var o = _g3[_g2++];
			while(this.menu.items[idx].length == 0) ++idx;
			this.menu.items[idx++][0] = o.name(this.node.setting);
		}
		app_MenuControl.prototype.step.call(this,x,y,touching);
	}
	,__class__: app_NodeEditControl
});
var app_NodeInfo = function(fullName,labelName,type,role,inParams,outParams) {
	this.fullName = fullName;
	this.labelName = labelName;
	this.type = type;
	this.role = role;
	this.inParams = inParams;
	this.outParams = outParams;
};
app_NodeInfo.__name__ = true;
app_NodeInfo.prototype = {
	create: function(g,x,y) {
		var node = this.type;
		var node1 = this.labelName;
		var role = this.role;
		var node2;
		switch(role._hx_index) {
		case 6:
			var _g1 = role.env;
			node2 = synth_NodeRole.Envelope(new synth_EnvelopeData(_g1.a,_g1.d,_g1.s,_g1.r));
			break;
		case 7:
			node2 = synth_NodeRole.Number(new synth_NumberData(role.num.get_value()));
			break;
		default:
			node2 = role;
		}
		var node3 = g.createNode(x,y,node,new graph_NodeSetting(node1,node2));
		var ang = 0.0;
		var _g = 0;
		var _g11 = this.inParams;
		while(_g < _g11.length) {
			node3.createSocket(graph_SocketType.Param(false,_g11[_g++])).phys.setNormal(-Math.cos(ang),Math.sin(ang));
			ang += Math.PI / 6;
		}
		ang = 0;
		var _g2 = 0;
		var _g3 = this.outParams;
		while(_g2 < _g3.length) {
			node3.createSocket(graph_SocketType.Param(false,_g3[_g2++])).phys.setNormal(Math.cos(ang),Math.sin(ang));
			ang += Math.PI / 6;
		}
		return node3;
	}
	,__class__: app_NodeInfo
};
var app__$NodeList_Eith_$Impl_$ = {};
app__$NodeList_Eith_$Impl_$.__name__ = true;
app__$NodeList_Eith_$Impl_$.fromL = function(l) {
	return haxe_ds_Either.Left(l);
};
app__$NodeList_Eith_$Impl_$.fromR = function(r) {
	return haxe_ds_Either.Right(r);
};
var synth_NodeRole = $hxEnums["synth.NodeRole"] = { __ename__ : true, __constructs__ : ["Frequency","Oscillator","Destination","Delay","Filter","Compressor","Envelope","Number","BinOp","Dupl","None"]
	,Frequency: {_hx_index:0,__enum__:"synth.NodeRole",toString:$estr}
	,Oscillator: ($_=function(type) { return {_hx_index:1,type:type,__enum__:"synth.NodeRole",toString:$estr}; },$_.__params__ = ["type"],$_)
	,Destination: {_hx_index:2,__enum__:"synth.NodeRole",toString:$estr}
	,Delay: {_hx_index:3,__enum__:"synth.NodeRole",toString:$estr}
	,Filter: ($_=function(type) { return {_hx_index:4,type:type,__enum__:"synth.NodeRole",toString:$estr}; },$_.__params__ = ["type"],$_)
	,Compressor: {_hx_index:5,__enum__:"synth.NodeRole",toString:$estr}
	,Envelope: ($_=function(env) { return {_hx_index:6,env:env,__enum__:"synth.NodeRole",toString:$estr}; },$_.__params__ = ["env"],$_)
	,Number: ($_=function(num) { return {_hx_index:7,num:num,__enum__:"synth.NodeRole",toString:$estr}; },$_.__params__ = ["num"],$_)
	,BinOp: ($_=function(type) { return {_hx_index:8,type:type,__enum__:"synth.NodeRole",toString:$estr}; },$_.__params__ = ["type"],$_)
	,Dupl: {_hx_index:9,__enum__:"synth.NodeRole",toString:$estr}
	,None: {_hx_index:10,__enum__:"synth.NodeRole",toString:$estr}
};
var graph_NodeType = $hxEnums["graph.NodeType"] = { __ename__ : true, __constructs__ : ["Normal","Module","Small","Boundary"]
	,Normal: ($_=function(input,output) { return {_hx_index:0,input:input,output:output,__enum__:"graph.NodeType",toString:$estr}; },$_.__params__ = ["input","output"],$_)
	,Module: ($_=function(input,output) { return {_hx_index:1,input:input,output:output,__enum__:"graph.NodeType",toString:$estr}; },$_.__params__ = ["input","output"],$_)
	,Small: {_hx_index:2,__enum__:"graph.NodeType",toString:$estr}
	,Boundary: ($_=function(io) { return {_hx_index:3,io:io,__enum__:"graph.NodeType",toString:$estr}; },$_.__params__ = ["io"],$_)
};
var synth_EnvelopeData = function(a,d,s,r) {
	this.a = a;
	this.d = d;
	this.s = s;
	this.r = r;
};
synth_EnvelopeData.__name__ = true;
synth_EnvelopeData.prototype = {
	__class__: synth_EnvelopeData
};
var synth_NumberData = function(x) {
	this.set_value(x);
};
synth_NumberData.__name__ = true;
synth_NumberData.prototype = {
	get_value: function() {
		return this.valueInt / 10000;
	}
	,set_value: function(v) {
		v = v > 10000 ? 10000 : v < -10000 ? -10000 : v;
		var vi = Math.round(v * 10000);
		if(vi == 0 && v != 0) {
			vi = v > 0 ? 1 : -1;
		}
		this.valueInt = vi;
		return this.get_value();
	}
	,__class__: synth_NumberData
};
var app_NodeList = function() { };
app_NodeList.__name__ = true;
app_NodeList.changeValue = function(values,sign,current) {
	var index = 0;
	var minDiff = 1e6;
	var _g = 0;
	var _g1 = values.length;
	while(_g < _g1) {
		var i = _g++;
		var diff = Math.abs(current - values[i]);
		if(diff < minDiff) {
			minDiff = diff;
			index = i;
		}
	}
	index += sign;
	index = index < 0 ? 0 : index > values.length - 1 ? values.length - 1 : index;
	return values[index];
};
app_NodeList.changeValueText = function(prefix,values,sign,current) {
	var currentStr = prefix + " " + (current == null ? "null" : "" + current);
	if(sign == -1) {
		currentStr = StringTools.rpad(""," ",currentStr.length);
	}
	return currentStr + " -> " + app_NodeList.changeValue(values,sign,current);
};
var app__$NumberEditControl_NumberType = $hxEnums["app._NumberEditControl.NumberType"] = { __ename__ : true, __constructs__ : ["Real","Time","Normalized"]
	,Real: {_hx_index:0,__enum__:"app._NumberEditControl.NumberType",toString:$estr}
	,Time: {_hx_index:1,__enum__:"app._NumberEditControl.NumberType",toString:$estr}
	,Normalized: {_hx_index:2,__enum__:"app._NumberEditControl.NumberType",toString:$estr}
};
var app_NumberEditControl = function(context,node,title,initialValue,onChange,getNextControl,type) {
	app_MenuControl.call(this,context);
	this.node = node;
	this.title = title;
	this.onChange = onChange;
	this.getNextControl = getNextControl;
	var labels;
	switch(type._hx_index) {
	case 0:
		this.offset = [100,-100,10,-10,1,-1,0.1,-0.1,0.01,-0.01,0,0,0,0];
		this.scale = [1,1,1,1,1,1,1,1,1,1,10,0.1,0,-1];
		labels = [["+100","-100"],["+10","-10"],["+1","-1"],["+0.1","-0.1"],["+0.01","-0.01"],["×10","÷10"],["0","+/-"]];
		this.min = -10000;
		this.max = 10000;
		break;
	case 1:
		this.offset = [1,-1,0.1,-0.1,0.01,-0.01,0.001,-0.001,0,0,0];
		this.scale = [1,1,1,1,1,1,1,1,10,0.1,0];
		labels = [["+1","-1"],["+0.1","-0.1"],["+0.01","-0.01"],["+0.001","-0.001"],["×10","÷10"],["0"]];
		this.min = 0;
		this.max = 10;
		break;
	case 2:
		this.offset = [0.1,-0.1,0.01,-0.01,0.001,-0.001,0,0,0,1];
		this.scale = [1,1,1,1,1,1,10,0.1,0,0];
		labels = [["+0.1","-0.1"],["+0.01","-0.01"],["+0.001","-0.001"],["×10","÷10"],["0","1"]];
		this.min = 0;
		this.max = 1;
		break;
	}
	this.menu = new app_Menu(title,labels);
	this.menu.items.push(["close"]);
	this.number = initialValue;
};
app_NumberEditControl.__name__ = true;
app_NumberEditControl.createValueEdit = function(context,node,num,next) {
	var res = next != null ? next : function() {
		return new app_MainControl(context);
	};
	var res1 = new app_NumberEditControl(context,node,"Value",num.get_value(),function(n) {
		return num.set_value(n);
	},res,app__$NumberEditControl_NumberType.Real);
	res1.menu.items.splice(-1,0,[]);
	res1.menu.items.splice(-1,0,["remove"]);
	res1.menu.items.splice(-1,0,["copy"]);
	return res1;
};
app_NumberEditControl.createAttackEdit = function(context,node,env,next) {
	var tmp = next != null ? next : function() {
		return new app_NodeEditControl(context,node);
	};
	return new app_NumberEditControl(context,node,"Attack",env.a,function(n) {
		return env.a = n;
	},tmp,app__$NumberEditControl_NumberType.Time);
};
app_NumberEditControl.createDecayEdit = function(context,node,env,next) {
	var tmp = next != null ? next : function() {
		return new app_NodeEditControl(context,node);
	};
	return new app_NumberEditControl(context,node,"Decay",env.d,function(n) {
		return env.d = n;
	},tmp,app__$NumberEditControl_NumberType.Time);
};
app_NumberEditControl.createSustainEdit = function(context,node,env,next) {
	var tmp = next != null ? next : function() {
		return new app_NodeEditControl(context,node);
	};
	return new app_NumberEditControl(context,node,"Sustain",env.s,function(n) {
		return env.s = n;
	},tmp,app__$NumberEditControl_NumberType.Normalized);
};
app_NumberEditControl.createReleaseEdit = function(context,node,env,next) {
	var tmp = next != null ? next : function() {
		return new app_NodeEditControl(context,node);
	};
	return new app_NumberEditControl(context,node,"Release",env.r,function(n) {
		return env.r = n;
	},tmp,app__$NumberEditControl_NumberType.Time);
};
app_NumberEditControl.__super__ = app_MenuControl;
app_NumberEditControl.prototype = $extend(app_MenuControl.prototype,{
	onReleased: function(x,y,tapCount) {
		if(this.focus != -1) {
			if(this.focus < this.offset.length) {
				this.number = this.number * this.scale[this.focus] + this.offset[this.focus];
				this.number = this.number < this.min ? this.min : this.number > this.max ? this.max : this.number;
				var intNumber = Math.round(this.number * 10000);
				if(intNumber == 0 && this.number != 0) {
					intNumber = this.number > 0 ? 1 : -1;
				}
				this.number = intNumber / 10000;
				this.onChange(this.number);
				if(this.node != null) {
					this.node.notifyUpdate();
				}
			} else {
				var _g = [];
				var e = $getIterator(this.menu.items);
				while(e.hasNext()) {
					var x1 = $getIterator(e.next());
					while(x1.hasNext()) _g.push(x1.next());
				}
				if(_g[this.focus] == "remove") {
					this.get_graph().destroyNode(this.node);
				}
				var _g1 = [];
				var e1 = $getIterator(this.menu.items);
				while(e1.hasNext()) {
					var x2 = $getIterator(e1.next());
					while(x2.hasNext()) _g1.push(x2.next());
				}
				if(_g1[this.focus] == "copy") {
					this.context.clipboard.copyNode(this.node);
				}
				this.nextControl = this.getNextControl();
			}
		}
	}
	,step: function(x,y,touching) {
		this.menu.title = this.title + ":" + this.number;
		app_MenuControl.prototype.step.call(this,x,y,touching);
	}
	,__class__: app_NumberEditControl
});
var app_SelectNodesControl = function(context) {
	app_Control.call(this,context);
	this.pickRadius = app_UISetting.tapErrorThreshold / this.get_renderer().view.scale;
};
app_SelectNodesControl.__name__ = true;
app_SelectNodesControl.__super__ = app_Control;
app_SelectNodesControl.prototype = $extend(app_Control.prototype,{
	onLongPress: function(x,y,tapCount) {
		if(tapCount == 1) {
			if(this.get_graph().pick(x,y,1 | (16 | 32),this.pickRadius) == null) {
				this.nextControl = new app_ModuleCreationConfirmMenu(this.context);
			}
		}
	}
	,onReleased: function(x,y,tapCount) {
		if(tapCount == 1) {
			var v = this.get_graph().pick(x,y,1,this.pickRadius);
			if(v != null) {
				var _g = v.type;
				if(_g._hx_index == 0) {
					var _g1 = _g.n;
					if(!(_g1.type._hx_index == 3 || _g1.setting.role._hx_index == 2)) {
						_g1.selected = !_g1.selected;
						_g1.selectingCount = 0;
					}
				} else {
					throw new js__$Boot_HaxeError("not a node");
				}
			}
		}
	}
	,step: function(x,y,touching) {
		this.get_graph().stepPhysics();
		this.get_renderer().render(this.get_graph());
	}
	,__class__: app_SelectNodesControl
});
var app_UISetting = function() { };
app_UISetting.__name__ = true;
var app_AudioNodeTools = function() { };
app_AudioNodeTools.__name__ = true;
app_AudioNodeTools.connectSafe = function(src,targetNode,targetParam) {
	if(!app_AudioNodeTools.mapN.has(src)) {
		app_AudioNodeTools.mapN.set(src,new haxe_ds_ObjectMap());
	}
	if(!app_AudioNodeTools.mapP.has(src)) {
		app_AudioNodeTools.mapP.set(src,new haxe_ds_ObjectMap());
	}
	if(targetNode != null) {
		app_AudioNodeTools.mapN.get(src).set(targetNode,true);
		src.connect(targetNode);
	}
	if(targetParam != null) {
		app_AudioNodeTools.mapP.get(src).set(targetParam,true);
		src.connect(targetParam);
	}
};
app_AudioNodeTools.disconnectSafe = function(src,targetNode,targetParam) {
	if(!app_AudioNodeTools.mapN.has(src)) {
		app_AudioNodeTools.mapN.set(src,new haxe_ds_ObjectMap());
	}
	if(!app_AudioNodeTools.mapP.has(src)) {
		app_AudioNodeTools.mapP.set(src,new haxe_ds_ObjectMap());
	}
	if(targetNode != null) {
		app_AudioNodeTools.mapN.get(src).remove(targetNode);
		src.disconnect(targetNode);
	}
	if(targetParam != null) {
		app_AudioNodeTools.mapP.get(src).remove(targetParam);
		src.disconnect(targetParam);
	}
	if(targetNode == null && targetParam == null) {
		app_AudioNodeTools.mapN.get(src).h = { __keys__ : { }};
		app_AudioNodeTools.mapP.get(src).h = { __keys__ : { }};
		src.disconnect();
	}
	var n = app_AudioNodeTools.mapN.get(src).keys();
	while(n.hasNext()) src.connect(n.next());
	var p = app_AudioNodeTools.mapP.get(src).keys();
	while(p.hasNext()) src.connect(p.next());
};
var app__$WebAudioCompiler_NodeData = function(id,setting,target) {
	this.id = id;
	this.setting = setting;
	this.target = target;
};
app__$WebAudioCompiler_NodeData.__name__ = true;
app__$WebAudioCompiler_NodeData.prototype = {
	__class__: app__$WebAudioCompiler_NodeData
};
var app__$WebAudioCompiler_SocketData = function(id,nodeId,type,target) {
	this.id = id;
	this.nodeId = nodeId;
	this.type = type;
	this.target = target;
};
app__$WebAudioCompiler_SocketData.__name__ = true;
app__$WebAudioCompiler_SocketData.prototype = {
	__class__: app__$WebAudioCompiler_SocketData
};
var app__$WebAudioCompiler_SocketTarget = $hxEnums["app._WebAudioCompiler.SocketTarget"] = { __ename__ : true, __constructs__ : ["Node","Param"]
	,Node: ($_=function(n) { return {_hx_index:0,n:n,__enum__:"app._WebAudioCompiler.SocketTarget",toString:$estr}; },$_.__params__ = ["n"],$_)
	,Param: ($_=function(p) { return {_hx_index:1,p:p,__enum__:"app._WebAudioCompiler.SocketTarget",toString:$estr}; },$_.__params__ = ["p"],$_)
};
var app__$WebAudioCompiler_NodeTarget = $hxEnums["app._WebAudioCompiler.NodeTarget"] = { __ename__ : true, __constructs__ : ["Node","MultiNode"]
	,Node: ($_=function(n) { return {_hx_index:0,n:n,__enum__:"app._WebAudioCompiler.NodeTarget",toString:$estr}; },$_.__params__ = ["n"],$_)
	,MultiNode: ($_=function(n) { return {_hx_index:1,n:n,__enum__:"app._WebAudioCompiler.NodeTarget",toString:$estr}; },$_.__params__ = ["n"],$_)
};
var app__$WebAudioCompiler_MultiNode = function(ctx,mul) {
	this.ctx = ctx;
	this.mul = mul;
	this.inputs = [];
	this.output = ctx.createGain();
	this.output.gain.value = 0;
	this.const = app__$WebAudioCompiler_ConstNode.make(ctx,mul ? 1 : 0);
	app_AudioNodeTools.connectSafe(this.const,this.output);
	this.nodes = [];
};
app__$WebAudioCompiler_MultiNode.__name__ = true;
app__$WebAudioCompiler_MultiNode.prototype = {
	connectInput: function(input) {
		this.inputs.push(input);
		this.updateInputs();
	}
	,disconnectInput: function(input) {
		HxOverrides.remove(this.inputs,input);
		app_AudioNodeTools.disconnectSafe(input);
		this.updateInputs();
	}
	,updateInputs: function() {
		var _g = 0;
		var _g1 = this.inputs;
		while(_g < _g1.length) app_AudioNodeTools.disconnectSafe(_g1[_g++]);
		var _g2 = 0;
		var _g3 = this.nodes;
		while(_g2 < _g3.length) app_AudioNodeTools.disconnectSafe(_g3[_g2++]);
		this.nodes = [];
		if(this.mul) {
			this.const.gain.value = 1;
			var lastNode = this.output;
			var _g4 = 0;
			var _g5 = this.inputs;
			while(_g4 < _g5.length) {
				var n = _g5[_g4++];
				var gain = this.ctx.createGain();
				lastNode.gain.value = 0;
				app_AudioNodeTools.connectSafe(gain,null,lastNode.gain);
				this.nodes.push(gain);
				lastNode = gain;
				app_AudioNodeTools.connectSafe(n,gain);
			}
		} else {
			this.const.gain.value = 0;
			this.output.gain.value = 1;
			var _g41 = 0;
			var _g51 = this.inputs;
			while(_g41 < _g51.length) app_AudioNodeTools.connectSafe(_g51[_g41++],this.output);
		}
	}
	,__class__: app__$WebAudioCompiler_MultiNode
};
var app__$WebAudioCompiler_ConstNode = function() { };
app__$WebAudioCompiler_ConstNode.__name__ = true;
app__$WebAudioCompiler_ConstNode.make = function(ctx,x) {
	if(x == null) {
		x = 1.0;
	}
	var buf = ctx.createBuffer(1,256,ctx.sampleRate);
	buf.getChannelData(0).fill(1);
	var one = ctx.createBufferSource();
	one.buffer = buf;
	one.loop = true;
	one.start();
	var gain = ctx.createGain();
	app_AudioNodeTools.connectSafe(one,gain);
	gain.gain.value = x;
	return gain;
};
var graph_GraphListener = function() { };
graph_GraphListener.__name__ = true;
graph_GraphListener.__isInterface__ = true;
graph_GraphListener.prototype = {
	__class__: graph_GraphListener
};
var app_WebAudioCompiler = function() {
	this.waveDataBuffer = new Float32Array(1024);
	this.socketMap = new haxe_ds_IntMap();
	this.nodeMap = new haxe_ds_IntMap();
	this.ctx = new (window.AudioContext || window.webkitAudioContext)();
	this.ctx.suspend();
	var compressor = this.ctx.createDynamicsCompressor();
	var saturator = this.ctx.createScriptProcessor(1024);
	saturator.addEventListener("audioprocess",function(e) {
		var inL = e.inputBuffer.getChannelData(0);
		var inR = e.inputBuffer.getChannelData(1);
		var outL = e.outputBuffer.getChannelData(0);
		var outR = e.outputBuffer.getChannelData(1);
		var _g = 0;
		while(_g < 1024) {
			var i = _g++;
			var x = inL[i];
			outL[i] = isNaN(x) ? 0 : x < -1 ? -1 : x > 1 ? 1 : x;
			var x1 = inR[i];
			outR[i] = isNaN(x1) ? 0 : x1 < -1 ? -1 : x1 > 1 ? 1 : x1;
		}
	});
	this.masterGain = this.ctx.createGain();
	this.masterGain.gain.value = 0.0;
	var hiddenGain = this.ctx.createGain();
	hiddenGain.gain.value = 0.8;
	app_AudioNodeTools.connectSafe(compressor,saturator);
	app_AudioNodeTools.connectSafe(saturator,this.masterGain);
	app_AudioNodeTools.connectSafe(this.masterGain,hiddenGain);
	app_AudioNodeTools.connectSafe(hiddenGain,this.ctx.destination);
	this.dest = saturator;
	this.analyzer = this.ctx.createAnalyser();
	app_AudioNodeTools.connectSafe(this.masterGain,this.analyzer);
	this.startedOnce = false;
	this.suspended = true;
	this.lastFrequency = 0;
};
app_WebAudioCompiler.__name__ = true;
app_WebAudioCompiler.__interfaces__ = [graph_GraphListener];
app_WebAudioCompiler.prototype = {
	playStartSound: function() {
		var oscs = [this.ctx.createOscillator(),this.ctx.createOscillator(),this.ctx.createOscillator(),this.ctx.createOscillator()];
		oscs[0].type = "square";
		oscs[1].type = "square";
		oscs[2].type = "sawtooth";
		oscs[3].type = "sawtooth";
		oscs[0].frequency.value = 220;
		oscs[1].frequency.value = 293.33333333333331;
		oscs[2].frequency.value = 366.66666666666663;
		oscs[3].frequency.value = 440;
		var gain = this.ctx.createGain();
		var _g = 0;
		while(_g < oscs.length) {
			var osc = oscs[_g];
			++_g;
			osc.connect(gain);
			osc.start();
		}
		var time = this.ctx.currentTime;
		gain.gain.setValueAtTime(0,time);
		gain.gain.linearRampToValueAtTime(0.5,time + 1.0);
		gain.gain.linearRampToValueAtTime(0,time + 2.0);
		var compl = this.ctx.createDynamicsCompressor();
		gain.connect(compl);
		compl.connect(this.ctx.destination);
		compl.connect(this.analyzer);
	}
	,start: function() {
		if(this.suspended) {
			var time = this.ctx.currentTime;
			var gain = this.masterGain.gain;
			if(!this.startedOnce) {
				this.startedOnce = true;
				this.ctx.resume();
				this.playStartSound();
				gain.setValueAtTime(0,time);
				gain.linearRampToValueAtTime(0,time + 1.5);
				gain.linearRampToValueAtTime(1,time + 2.0);
			} else {
				gain.setValueAtTime(gain.value,time);
				gain.linearRampToValueAtTime(1,time + 0.01);
			}
			this.suspended = false;
		}
	}
	,stop: function() {
		if(!this.suspended) {
			var time = this.ctx.currentTime;
			var gain = this.masterGain.gain;
			gain.setValueAtTime(gain.value,time);
			gain.linearRampToValueAtTime(0,time + 0.01);
			this.suspended = true;
		}
	}
	,attack: function() {
		var n = this.nodeMap.iterator();
		while(n.hasNext()) {
			var n1 = n.next();
			var _g1 = n1.setting.role;
			if(_g1._hx_index == 6) {
				var _g2 = _g1.env;
				var gain = (js_Boot.__cast(this.getNodeOf(n1.id) , GainNode)).gain;
				var time = this.ctx.currentTime;
				gain.cancelScheduledValues(time);
				gain.setValueAtTime(gain.value,time);
				gain.linearRampToValueAtTime(1,time + _g2.a);
				gain.linearRampToValueAtTime(_g2.s,time + _g2.a + _g2.d);
			}
		}
	}
	,release: function() {
		var n = this.nodeMap.iterator();
		while(n.hasNext()) {
			var n1 = n.next();
			var _g1 = n1.setting.role;
			if(_g1._hx_index == 6) {
				var gain = (js_Boot.__cast(this.getNodeOf(n1.id) , GainNode)).gain;
				var time = this.ctx.currentTime;
				gain.cancelScheduledValues(time);
				gain.setValueAtTime(gain.value,time);
				gain.linearRampToValueAtTime(0,time + _g1.env.r);
			}
		}
	}
	,setFrequency: function(f,t) {
		this.lastFrequency = f;
		var n = this.nodeMap.iterator();
		while(n.hasNext()) {
			var n1 = n.next();
			if(n1.setting.role._hx_index == 0) {
				var gain = (js_Boot.__cast(this.getNodeOf(n1.id) , GainNode)).gain;
				var time = this.ctx.currentTime;
				gain.cancelScheduledValues(time);
				gain.setValueAtTime(gain.value,time);
				gain.linearRampToValueAtTime(f,time + t);
			}
		}
	}
	,onNodeCreated: function(id,setting) {
		console.log("src/app/WebAudioCompiler.hx:334:","node created: " + id);
		var target;
		var _g = setting.role;
		switch(_g._hx_index) {
		case 0:
			target = app__$WebAudioCompiler_NodeTarget.Node(app__$WebAudioCompiler_ConstNode.make(this.ctx,this.lastFrequency));
			break;
		case 1:
			var osc = this.ctx.createOscillator();
			osc.start();
			var target1;
			switch(_g.type) {
			case "saw":
				target1 = "sawtooth";
				break;
			case "sin":
				target1 = "sine";
				break;
			case "sq":
				target1 = "square";
				break;
			case "tri":
				target1 = "triangle";
				break;
			}
			osc.type = target1;
			target = app__$WebAudioCompiler_NodeTarget.Node(osc);
			break;
		case 2:
			target = app__$WebAudioCompiler_NodeTarget.Node(this.dest);
			break;
		case 3:
			target = app__$WebAudioCompiler_NodeTarget.Node(this.ctx.createDelay(5));
			break;
		case 4:
			var bq = this.ctx.createBiquadFilter();
			var target2;
			switch(_g.type) {
			case "bp":
				target2 = "bandpass";
				break;
			case "bs":
				target2 = "notch";
				break;
			case "hp":
				target2 = "highpass";
				break;
			case "hs":
				target2 = "highshelf";
				break;
			case "lp":
				target2 = "lowpass";
				break;
			case "ls":
				target2 = "lowshelf";
				break;
			case "p":
				target2 = "peaking";
				break;
			}
			bq.type = target2;
			target = app__$WebAudioCompiler_NodeTarget.Node(bq);
			break;
		case 5:
			target = app__$WebAudioCompiler_NodeTarget.Node(this.ctx.createDynamicsCompressor());
			break;
		case 6:
			target = app__$WebAudioCompiler_NodeTarget.Node(app__$WebAudioCompiler_ConstNode.make(this.ctx,0));
			break;
		case 7:
			target = app__$WebAudioCompiler_NodeTarget.Node(app__$WebAudioCompiler_ConstNode.make(this.ctx,_g.num.get_value()));
			break;
		case 8:
			var target3;
			switch(_g.type) {
			case 0:
				target3 = false;
				break;
			case 1:
				target3 = true;
				break;
			}
			target = app__$WebAudioCompiler_NodeTarget.MultiNode(new app__$WebAudioCompiler_MultiNode(this.ctx,target3));
			break;
		case 9:
			target = app__$WebAudioCompiler_NodeTarget.MultiNode(new app__$WebAudioCompiler_MultiNode(this.ctx,false));
			break;
		case 10:
			throw new js__$Boot_HaxeError("this should not be created");
		}
		this.nodeMap.h[id] = new app__$WebAudioCompiler_NodeData(id,setting,target);
	}
	,onNodeDestroyed: function(id) {
		console.log("src/app/WebAudioCompiler.hx:384:","node destroyed: " + id);
		this.nodeMap.remove(id);
	}
	,getNodeOf: function(id) {
		var _g = this.nodeMap.h[id].target;
		switch(_g._hx_index) {
		case 0:
			return _g.n;
		case 1:
			return _g.n;
		}
	}
	,onSocketCreated: function(id,nodeId,type) {
		console.log("src/app/WebAudioCompiler.hx:396:","socket created: " + id);
		var node = this.nodeMap.h[nodeId];
		var target;
		switch(type._hx_index) {
		case 0:
			if(type.io) {
				var terminal = this.ctx.createGain();
				var _g = node.target;
				switch(_g._hx_index) {
				case 0:
					app_AudioNodeTools.connectSafe(_g.n,terminal);
					break;
				case 1:
					app_AudioNodeTools.connectSafe(_g.n.output,terminal);
					break;
				}
				target = app__$WebAudioCompiler_SocketTarget.Node(app__$WebAudioCompiler_NodeTarget.Node(terminal));
			} else {
				target = app__$WebAudioCompiler_SocketTarget.Node(node.target);
			}
			break;
		case 1:
			var _g1 = type.name;
			if(type.io) {
				throw new js__$Boot_HaxeError("output param not supported");
			} else {
				var target1;
				switch(node.setting.role._hx_index) {
				case 1:
					var osc = js_Boot.__cast(this.getNodeOf(nodeId) , OscillatorNode);
					switch(_g1) {
					case "detune":
						target1 = osc.detune;
						break;
					case "freq":
						target1 = osc.frequency;
						break;
					default:
						throw new js__$Boot_HaxeError("!?");
					}
					break;
				case 3:
					if(_g1 == "time") {
						target1 = (js_Boot.__cast(this.getNodeOf(nodeId) , DelayNode)).delayTime;
					} else {
						throw new js__$Boot_HaxeError("!?");
					}
					break;
				case 4:
					var bq = js_Boot.__cast(this.getNodeOf(nodeId) , BiquadFilterNode);
					switch(_g1) {
					case "Q":
						target1 = bq.Q;
						break;
					case "freq":
						target1 = bq.frequency;
						break;
					case "gain":
						target1 = bq.gain;
						break;
					default:
						throw new js__$Boot_HaxeError("!?");
					}
					break;
				default:
					throw new js__$Boot_HaxeError("not implemented yet");
				}
				target = app__$WebAudioCompiler_SocketTarget.Param(target1);
			}
			break;
		case 2:
			throw new js__$Boot_HaxeError("this should never happen");
		}
		this.socketMap.h[id] = new app__$WebAudioCompiler_SocketData(id,nodeId,type,target);
	}
	,onSocketDestroyed: function(id) {
		console.log("src/app/WebAudioCompiler.hx:452:","socket destroyed: " + id);
		var s = this.socketMap.h[id];
		var _g = s.type;
		if(_g._hx_index == 0 && _g.io == true) {
			var terminal;
			var _g2 = s.target;
			if(_g2._hx_index == 0) {
				var _g3 = _g2.n;
				if(_g3._hx_index == 0) {
					terminal = _g3.n;
				} else {
					throw new js__$Boot_HaxeError("!?");
				}
			} else {
				throw new js__$Boot_HaxeError("!?");
			}
			var _g4 = this.nodeMap.h[s.nodeId].target;
			switch(_g4._hx_index) {
			case 0:
				app_AudioNodeTools.disconnectSafe(_g4.n,terminal);
				break;
			case 1:
				app_AudioNodeTools.connectSafe(_g4.n.output,terminal);
				break;
			}
		}
		this.socketMap.remove(id);
	}
	,onSocketConnected: function(id1,id2) {
		console.log("src/app/WebAudioCompiler.hx:473:","connected: " + id1 + "->" + id2);
		var s2 = this.socketMap.h[id2];
		var _g = this.socketMap.h[id1].target;
		switch(_g._hx_index) {
		case 0:
			var _g1 = _g.n;
			switch(_g1._hx_index) {
			case 0:
				var _g2 = _g1.n;
				var _g3 = s2.target;
				switch(_g3._hx_index) {
				case 0:
					var _g11 = _g3.n;
					switch(_g11._hx_index) {
					case 0:
						app_AudioNodeTools.connectSafe(_g2,_g11.n);
						break;
					case 1:
						_g11.n.connectInput(_g2);
						break;
					}
					break;
				case 1:
					var _g21 = _g3.p;
					app_AudioNodeTools.connectSafe(_g2,null,_g21);
					_g21.value = 0;
					break;
				}
				break;
			case 1:
				throw new js__$Boot_HaxeError("cannot connect directly from multinode");
			}
			break;
		case 1:
			throw new js__$Boot_HaxeError("cannot connect from param");
		}
	}
	,onSocketDisconnected: function(id1,id2) {
		console.log("src/app/WebAudioCompiler.hx:501:","disconnected: " + id1 + "->" + id2);
		var s2 = this.socketMap.h[id2];
		var _g = this.socketMap.h[id1].target;
		switch(_g._hx_index) {
		case 0:
			var _g1 = _g.n;
			switch(_g1._hx_index) {
			case 0:
				var _g2 = _g1.n;
				var _g3 = s2.target;
				switch(_g3._hx_index) {
				case 0:
					var _g11 = _g3.n;
					switch(_g11._hx_index) {
					case 0:
						app_AudioNodeTools.disconnectSafe(_g2,_g11.n);
						break;
					case 1:
						_g11.n.disconnectInput(_g2);
						break;
					}
					break;
				case 1:
					var _g21 = _g3.p;
					app_AudioNodeTools.disconnectSafe(_g2,null,_g21);
					_g21.value = _g21.defaultValue;
					break;
				}
				break;
			case 1:
				throw new js__$Boot_HaxeError("cannot disconnect directly from multinode");
			}
			break;
		case 1:
			throw new js__$Boot_HaxeError("cannot disconnect from param");
		}
	}
	,onNodeUpdated: function(id) {
		var _g = this.nodeMap.h[id].setting.role;
		switch(_g._hx_index) {
		case 1:
			var osc = js_Boot.__cast(this.getNodeOf(id) , OscillatorNode);
			var tmp;
			switch(_g.type) {
			case "saw":
				tmp = "sawtooth";
				break;
			case "sin":
				tmp = "sine";
				break;
			case "sq":
				tmp = "square";
				break;
			case "tri":
				tmp = "triangle";
				break;
			}
			osc.type = tmp;
			break;
		case 7:
			(js_Boot.__cast(this.getNodeOf(id) , GainNode)).gain.value = _g.num.get_value();
			break;
		case 8:
			var multi = js_Boot.__cast(this.getNodeOf(id) , app__$WebAudioCompiler_MultiNode);
			var tmp1;
			switch(_g.type) {
			case 0:
				tmp1 = false;
				break;
			case 1:
				tmp1 = true;
				break;
			}
			multi.mul = tmp1;
			multi.updateInputs();
			break;
		default:
		}
	}
	,onWaveDataRequest: function(outArray) {
		if(this.suspended) {
			return;
		}
		this.analyzer.getFloatTimeDomainData(this.waveDataBuffer);
		var _g = 0;
		while(_g < 256) outArray.push(this.waveDataBuffer[_g++]);
	}
	,__class__: app_WebAudioCompiler
};
var graph_CableInfo = function() {
	this.vertex = null;
	this.edge = null;
};
graph_CableInfo.__name__ = true;
graph_CableInfo.prototype = {
	__class__: graph_CableInfo
};
var graph_Edge = function(v1,v2,length,stiff) {
	this.v1 = v1;
	this.v2 = v2;
	this.spring = new phys_Spring(v1.point,v2.point,length,stiff);
	this.firstEdgeOf = null;
	this.lastEdgeOf = null;
};
graph_Edge.__name__ = true;
graph_Edge.prototype = {
	connect: function() {
		this.v1.edges.push(this);
		this.v2.edges.push(this);
	}
	,disconnect: function() {
		var ok = true;
		ok = HxOverrides.remove(this.v1.edges,this);
		ok = ok && HxOverrides.remove(this.v2.edges,this);
		if(!ok) {
			throw new js__$Boot_HaxeError("couldn't disconnect");
		}
	}
	,__class__: graph_Edge
};
var graph__$Graph_EmptyGraphListener = function() {
};
graph__$Graph_EmptyGraphListener.__name__ = true;
graph__$Graph_EmptyGraphListener.__interfaces__ = [graph_GraphListener];
graph__$Graph_EmptyGraphListener.prototype = {
	onNodeCreated: function(id,setting) {
	}
	,onNodeDestroyed: function(id) {
	}
	,onSocketCreated: function(id,nodeId,type) {
	}
	,onSocketDestroyed: function(id) {
	}
	,onSocketConnected: function(id1,id2) {
	}
	,onSocketDisconnected: function(id1,id2) {
	}
	,onNodeUpdated: function(id) {
	}
	,onWaveDataRequest: function(arrayOut) {
	}
	,__class__: graph__$Graph_EmptyGraphListener
};
var graph_Graph = function(listener) {
	this.listener = listener != null ? listener : new graph__$Graph_EmptyGraphListener();
	this.world = new phys_World();
	this.nodes = [];
	this.vertices = [];
	this.edges = [];
};
graph_Graph.__name__ = true;
graph_Graph.deserialize = function(data,listener) {
	var g = new graph_Graph(listener);
	var _g = 0;
	var _g1 = data.nodes;
	while(_g < _g1.length) {
		var n = _g1[_g];
		++_g;
		var node = g.createNode(n.x / 10000,n.y / 10000,graph_Node.deserializeType(n.type),graph_NodeSetting.deserialize(n.setting));
		if(node.type._hx_index == 1) {
			node.moduleGraph = graph_Graph.deserialize(n.graph,listener);
			node.moduleGraph.parent = g;
			var _this = n.boundaries;
			var result = new Array(_this.length);
			var _g2 = 0;
			var _g11 = _this.length;
			while(_g2 < _g11) {
				var i = _g2++;
				result[i] = node.moduleGraph.nodes[_this[i]];
			}
			node.moduleBoundaries = result;
		}
		var _g3 = 0;
		var _g4 = n.sockets;
		while(_g3 < _g4.length) {
			var s = _g4[_g3];
			++_g3;
			node.createSocket(graph_Socket.deserializeType(s.type,node.moduleBoundaries)).phys.setAngle(s.angle / 10000);
		}
	}
	var _g21 = 0;
	var _g31 = data.connections;
	while(_g21 < _g31.length) {
		var c = _g31[_g21];
		++_g21;
		g.connectCable(g.nodes[c.n1].sockets[c.s1].phys.vertex,g.nodes[c.n2].sockets[c.s2].phys.vertex);
	}
	g.updateConnections();
	return g;
};
graph_Graph.prototype = {
	bakeView: function(view) {
		var _g = 0;
		var _g1 = this.vertices;
		while(_g < _g1.length) {
			var v = _g1[_g];
			++_g;
			v.point.x -= view.centerX;
			v.point.y -= view.centerY;
		}
		view.centerX = 0;
		view.centerY = 0;
	}
	,createNode: function(x,y,type,setting) {
		var n = new graph_Node(this,x,y,type,setting);
		this.nodes.push(n);
		if(n.type._hx_index != 1) {
			this.listener.onNodeCreated(n.id,n.setting);
		}
		this.updateRequired = true;
		return n;
	}
	,createNodeByDataAt: function(x,y,data) {
		var node = this.createNode(x,y,graph_Node.deserializeType(data.type),graph_NodeSetting.deserialize(data.setting));
		if(node.type._hx_index == 1) {
			node.moduleGraph = graph_Graph.deserialize(data.graph,this.listener);
			node.moduleGraph.parent = this;
			var _this = data.boundaries;
			var result = new Array(_this.length);
			var _g = 0;
			var _g1 = _this.length;
			while(_g < _g1) {
				var i = _g++;
				result[i] = node.moduleGraph.nodes[_this[i]];
			}
			node.moduleBoundaries = result;
		}
		var _g3 = 0;
		var _g4 = data.sockets;
		while(_g3 < _g4.length) {
			var s = _g4[_g3];
			++_g3;
			node.createSocket(graph_Socket.deserializeType(s.type,node.moduleBoundaries)).phys.setAngle(s.angle / 10000);
		}
		this.updateRequired = true;
		return node;
	}
	,insertNode: function(v,n) {
		if(v.type != graph_VertexType.Normal) {
			return false;
		}
		var inputs = [];
		var outputs = [];
		var _g = 0;
		var _g1 = v.edges;
		while(_g < _g1.length) {
			var e = _g1[_g];
			++_g;
			if(v != e.v1) {
				inputs.push(e.v1);
			}
			if(v != e.v2) {
				outputs.push(e.v2);
			}
		}
		this.destroyVertex(v);
		var _g2 = 0;
		while(_g2 < inputs.length) {
			var v1 = inputs[_g2];
			++_g2;
			v1.vibrate(true);
			var s = n.createSocket(graph_SocketType.Normal(false));
			s.phys.lookAt(v1.point.x,v1.point.y);
			this.createEdge(v1,s.phys.vertex);
		}
		var _g3 = 0;
		while(_g3 < outputs.length) {
			var v2 = outputs[_g3];
			++_g3;
			v2.vibrate(true);
			var s1 = n.createSocket(graph_SocketType.Normal(true));
			s1.phys.lookAt(v2.point.x,v2.point.y);
			this.createEdge(s1.phys.vertex,v2);
		}
		return true;
	}
	,createModule: function(nodesToContain) {
		var boundaries = [];
		var cableEdges = [];
		this.isolateNodesAndCutCables(nodesToContain,boundaries,cableEdges);
		return this.createModuleAndConnectCables(nodesToContain,boundaries,cableEdges);
	}
	,isolateNodesAndCutCables: function(nodesToContain,outBoundaries,outCableEdges) {
		var boundaryName = "A";
		var _g = 0;
		while(_g < nodesToContain.length) {
			var n = nodesToContain[_g];
			++_g;
			var _g1 = 0;
			var _g11 = n.sockets;
			while(_g1 < _g11.length) {
				var s = _g11[_g1];
				++_g1;
				var _g2 = 0;
				var _g12 = s.connections;
				while(_g2 < _g12.length) {
					var c = _g12[_g2];
					++_g2;
					var s2 = c.other(s);
					if(nodesToContain.indexOf(s2.parent) == -1) {
						var s2p = s2.phys;
						var v1 = s.phys.vertex;
						var v2 = s2p.vertex;
						var n1v = n.phys.vertex;
						var ratio = 0.9;
						var boundaryNode = this.createNode(v1.point.x + (v2.point.x - v1.point.x) * ratio,v1.point.y + (v2.point.y - v1.point.y) * ratio,graph_NodeType.Boundary(graph_SocketTypeTool.io(s2.type)),new graph_NodeSetting(boundaryName,synth_NodeRole.Dupl));
						outBoundaries.push(boundaryNode);
						var code = HxOverrides.cca(boundaryName,0) + 1;
						boundaryName = String.fromCodePoint(code);
						var boundarySocketPhys = boundaryNode.createSocket(graph_SocketType.Normal(graph_SocketTypeTool.io(s2.type))).phys;
						boundarySocketPhys.lookAt(n1v.point.x,n1v.point.y);
						var edgeToCut = c.nearestEdge(s2);
						var cutCableSocket1Side = s2p.vertex != edgeToCut.v1 ? edgeToCut.v1 : edgeToCut.v2;
						this.destroyEdge(edgeToCut);
						outCableEdges.push(v2);
						if(graph_SocketTypeTool.io(s.type)) {
							this.createEdge(cutCableSocket1Side,boundarySocketPhys.vertex);
						} else {
							this.createEdge(boundarySocketPhys.vertex,cutCableSocket1Side);
						}
					}
				}
			}
		}
	}
	,createModuleAndConnectCables: function(nodesToContain,boundaries,cables) {
		if(nodesToContain.length == 0) {
			return null;
		}
		var meanX = 0.0;
		var meanY = 0.0;
		var _g = 0;
		while(_g < nodesToContain.length) {
			var n = nodesToContain[_g];
			++_g;
			meanX += n.phys.vertex.point.x;
			meanY += n.phys.vertex.point.y;
		}
		meanX /= nodesToContain.length;
		meanY /= nodesToContain.length;
		var module = this.createNode(meanX,meanY,graph_NodeType.Module(false,false),new graph_NodeSetting("mod",synth_NodeRole.None));
		module.moduleBoundaries = boundaries;
		this.updateConnections();
		this.transferModule(nodesToContain.concat(boundaries),module.moduleGraph);
		var _g1 = 0;
		var _g2 = boundaries.length;
		while(_g1 < _g2) {
			var i = _g1++;
			var boundary = boundaries[i];
			var cable = cables[i];
			var _g11 = boundary.type;
			if(_g11._hx_index == 3) {
				var socketIO = !_g11.io;
				var sp = module.createSocket(boundary.setting.name == "" ? graph_SocketType.Normal(socketIO) : graph_SocketType.Module(socketIO,boundary)).phys;
				sp.lookAt(cable.point.x,cable.point.y);
				if(socketIO) {
					this.connectCable(sp.vertex,cable);
				} else {
					this.connectCable(cable,sp.vertex);
				}
			} else {
				throw new js__$Boot_HaxeError("not a boundary node");
			}
		}
		var bv = module.moduleGraph.computeBoundingVolume();
		var _g3 = 0;
		var _g4 = module.moduleGraph.vertices;
		while(_g3 < _g4.length) {
			var v = _g4[_g3];
			++_g3;
			v.point.x -= bv.x;
			v.point.y -= bv.y;
		}
		return module;
	}
	,transferModule: function(ns,to) {
		if(this == to) {
			throw new js__$Boot_HaxeError("cannot tranfer");
		}
		this.dfs(null,null,true);
		var vs = [];
		var es = new haxe_ds_ObjectMap();
		var _g = 0;
		while(_g < ns.length) this.dfs(function(v) {
			vs.push(v);
			var _g1 = 0;
			var _g11 = v.edges;
			while(_g1 < _g11.length) es.set(_g11[_g1++],true);
			return true;
		},ns[_g++].phys.vertex,false);
		var ok = true;
		var _g12 = 0;
		while(_g12 < vs.length) {
			var v1 = vs[_g12];
			++_g12;
			ok = ok && this.world.removePoint(v1.point);
			to.world.addPoint(v1.point);
			ok = ok && HxOverrides.remove(this.vertices,v1);
			to.vertices.push(v1);
		}
		var e = es.keys();
		while(e.hasNext()) {
			var e1 = e.next();
			ok = ok && this.world.removeSpring(e1.spring);
			to.world.addSpring(e1.spring);
			ok = ok && HxOverrides.remove(this.edges,e1);
			to.edges.push(e1);
		}
		var _g2 = 0;
		while(_g2 < ns.length) {
			var n = ns[_g2];
			++_g2;
			ok = ok && HxOverrides.remove(this.nodes,n);
			to.nodes.push(n);
			n.g = to;
			var _g21 = 0;
			var _g3 = n.sockets;
			while(_g21 < _g3.length) _g3[_g21++].g = to;
		}
		if(!ok) {
			throw new js__$Boot_HaxeError("transfer failed");
		}
		this.updateRequired = true;
		to.updateRequired = true;
	}
	,computeBoundingVolume: function() {
		if(this.nodes.length == 0) {
			return new graph_GraphBoundingVolume(0,0,1);
		}
		var x = 0.0;
		var y = 0.0;
		var denom = 0.0;
		var _g = 0;
		var _g1 = this.nodes;
		while(_g < _g1.length) {
			var n = _g1[_g];
			++_g;
			if(n.type._hx_index == 3) {
				continue;
			}
			var p = n.phys.vertex.point;
			x += p.x;
			y += p.y;
			++denom;
		}
		var invV = 1 / (denom == 0 ? 1 : denom);
		x *= invV;
		y *= invV;
		var r = 0.0;
		var _g2 = 0;
		var _g3 = this.nodes;
		while(_g2 < _g3.length) {
			var n1 = _g3[_g2];
			++_g2;
			if(n1.type._hx_index == 3) {
				continue;
			}
			var p1 = n1.phys.vertex.point;
			var dx = x - p1.x;
			var dy = y - p1.y;
			var r2 = dx * dx + dy * dy;
			if(r2 > r * r) {
				r = Math.sqrt(r2);
			}
		}
		return new graph_GraphBoundingVolume(x,y,r);
	}
	,copyNode: function(n) {
		var np = n.phys;
		var np1 = np.vertex.point.x;
		var np2 = np.vertex.point.y;
		var n1 = n.type;
		var n2 = n.setting.name;
		var role = n.setting.role;
		var n21;
		switch(role._hx_index) {
		case 6:
			var _g1 = role.env;
			n21 = synth_NodeRole.Envelope(new synth_EnvelopeData(_g1.a,_g1.d,_g1.s,_g1.r));
			break;
		case 7:
			n21 = synth_NodeRole.Number(new synth_NumberData(role.num.get_value()));
			break;
		default:
			n21 = role;
		}
		var n22 = this.createNode(np1,np2,n1,new graph_NodeSetting(n2,n21));
		n22.phys.vertex.point.x = np.vertex.point.x;
		n22.phys.vertex.point.y = np.vertex.point.y;
		if(n.type._hx_index == 1) {
			var g1 = n.moduleGraph;
			var g2 = n22.moduleGraph;
			var _g3 = 0;
			var _g4 = g1.nodes;
			while(_g3 < _g4.length) g2.copyNode(_g4[_g3++]);
			var _g5 = 0;
			var _g6 = g1.nodes.length;
			while(_g5 < _g6) {
				var i = _g5++;
				var n11 = g1.nodes[i];
				var n23 = g2.nodes[i];
				var _g51 = 0;
				var _g61 = n11.sockets.length;
				while(_g51 < _g61) {
					var j = _g51++;
					var s1 = n11.sockets[j];
					var s2 = n23.sockets[j];
					if(graph_SocketTypeTool.io(s1.type) != true) {
						continue;
					}
					var _g52 = 0;
					var _g62 = s1.connections;
					while(_g52 < _g62.length) {
						var to1 = _g62[_g52++].to;
						g2.createEdge(s2.phys.vertex,g2.nodes[g1.nodes.indexOf(to1.parent)].sockets[to1.parent.sockets.indexOf(to1)].phys.vertex);
					}
				}
			}
			g2.updateConnections();
			var _this = n.moduleBoundaries;
			var result = new Array(_this.length);
			var _g = 0;
			var _g11 = _this.length;
			while(_g < _g11) {
				var i1 = _g++;
				result[i1] = g2.nodes[g1.nodes.indexOf(_this[i1])];
			}
			n22.moduleBoundaries = result;
		}
		var _g31 = 0;
		var _g41 = n.sockets;
		while(_g31 < _g41.length) {
			var s = _g41[_g31];
			++_g31;
			var _g32 = s.type;
			var s21 = n22.createSocket(_g32._hx_index == 2 ? graph_SocketType.Module(_g32.io,n22.moduleBoundaries[n.moduleBoundaries.indexOf(_g32.boundary)]) : s.type);
			s.phys.computeDrawingPos();
			s21.phys.setNormal(s.phys.normalX,s.phys.normalY);
		}
		return n22;
	}
	,decomposeModule: function(node) {
		var g = node.moduleGraph;
		var bv = g.computeBoundingVolume();
		var np = node.phys;
		var _g = 0;
		var _g1 = g.vertices;
		while(_g < _g1.length) {
			var v = _g1[_g];
			++_g;
			v.point.x -= bv.x;
			v.point.y -= bv.y;
			v.point.x *= 0.5;
			v.point.y *= 0.5;
			v.point.x += np.vertex.point.x;
			v.point.y += np.vertex.point.y;
		}
		g.transferModule(g.nodes.slice(),this);
		var _g2 = 0;
		var _g3 = this.nodes;
		while(_g2 < _g3.length) {
			var _g21 = 0;
			var _g31 = _g3[_g2++].sockets;
			while(_g21 < _g31.length) {
				var s = _g31[_g21];
				++_g21;
				s.phys.lookAt(s.phys.vertex.point.x,s.phys.vertex.point.y);
			}
		}
		var boundaries = node.moduleBoundaries;
		var _g4 = [];
		var _g5 = 0;
		while(_g5 < boundaries.length) {
			++_g5;
			_g4.push([]);
		}
		var _g6 = [];
		var _g7 = 0;
		while(_g7 < boundaries.length) {
			++_g7;
			_g6.push([]);
		}
		var _g8 = 0;
		var _g9 = node.sockets;
		while(_g8 < _g9.length) {
			var s1 = _g9[_g8];
			++_g8;
			var sp = s1.phys;
			var parent;
			var _g81 = s1.type;
			if(_g81._hx_index == 2) {
				parent = _g81.boundary;
			} else {
				throw new js__$Boot_HaxeError("not a module socket");
			}
			var index = boundaries.indexOf(parent);
			var edges = sp.vertex.edges.slice();
			var _g11 = 0;
			while(_g11 < edges.length) {
				var e = edges[_g11];
				++_g11;
				if(e == sp.edge) {
					continue;
				}
				if(graph_SocketTypeTool.io(s1.type)) {
					_g6[index].push(sp.vertex != e.v1 ? e.v1 : e.v2);
				} else {
					_g4[index].push(sp.vertex != e.v1 ? e.v1 : e.v2);
				}
				this.destroyEdge(e);
			}
		}
		var _g10 = 0;
		var _g111 = boundaries.length;
		while(_g10 < _g111) {
			var i = _g10++;
			var b = boundaries[i];
			b.boundaryToNormal();
			var _g101 = 0;
			var _g112 = _g4[i];
			while(_g101 < _g112.length) {
				var v1 = _g112[_g101];
				++_g101;
				var s2 = b.createSocket(graph_SocketType.Normal(false));
				s2.phys.lookAt(v1.point.x,v1.point.y);
				this.createEdge(v1,s2.phys.vertex);
			}
			var _g12 = 0;
			var _g13 = _g6[i];
			while(_g12 < _g13.length) {
				var v2 = _g13[_g12];
				++_g12;
				var s3 = b.createSocket(graph_SocketType.Normal(true));
				s3.phys.lookAt(v2.point.x,v2.point.y);
				this.createEdge(s3.phys.vertex,v2);
			}
		}
		this.destroyNode(node);
	}
	,destroyNode: function(n) {
		var sockets = n.sockets.slice();
		var _g = 0;
		while(_g < sockets.length) n.destroySocket(sockets[_g++]);
		if(n.type._hx_index == 1) {
			n.moduleGraph.destroyEverything();
		} else {
			this.listener.onNodeDestroyed(n.id);
		}
		this.destroyVertexUnsafe(n.phys.vertex);
		HxOverrides.remove(this.nodes,n);
		this.updateRequired = true;
	}
	,destroyEverything: function() {
		var ns = this.nodes.slice();
		var _g = 0;
		while(_g < ns.length) this.destroyNode(ns[_g++]);
		var es = this.edges.slice();
		var _g1 = 0;
		while(_g1 < es.length) this.destroyEdge(es[_g1++]);
		var vs = this.vertices.slice();
		var _g2 = 0;
		while(_g2 < vs.length) this.destroyVertex(vs[_g2++]);
	}
	,connectCable: function(from,to) {
		var dx = to.point.x - from.point.x;
		var dy = to.point.y - from.point.y;
		var dist = Math.sqrt(dx * dx + dy * dy);
		var invDist = dist == 0 ? 0 : 1 / dist;
		var nx = dx * invDist;
		var ny = dy * invDist;
		var extended = [];
		while(dist > 5.) {
			var mid = this.createVertex(from.point.x + nx * 5.,from.point.y + ny * 5.,graph_VertexType.Normal,0.5);
			extended.push(mid);
			this.createEdge(from,mid);
			dist -= 5.;
			from = mid;
		}
		var _g = 0;
		while(_g < extended.length) extended[_g++].vibrate();
		this.createEdge(from,to);
	}
	,isConnectable: function(from,to) {
		if(from == to || !this.isOutput(from) || !this.isInput(to) || this.isInSameCable(from,to)) {
			return false;
		}
		return true;
	}
	,connectVertices: function(from,to) {
		if(!this.isConnectable(from,to)) {
			return false;
		}
		var dx = to.point.x - from.point.x;
		var dy = to.point.y - from.point.y;
		var dist = Math.sqrt(dx * dx + dy * dy);
		if(dist == 0) {
			dx = 0.1;
			dist = 0.010000000000000002;
		}
		var invDist = 1 / dist;
		var nx = dx * invDist;
		var ny = dy * invDist;
		var _g = from.type;
		if(_g._hx_index == 0) {
			var sp = _g.n.createSocket(graph_SocketType.Normal(true)).phys;
			sp.setNormal(nx,ny);
			from = sp.vertex;
		}
		var _g2 = to.type;
		if(_g2._hx_index == 0) {
			var sp1 = _g2.n.createSocket(graph_SocketType.Normal(false)).phys;
			sp1.setNormal(-nx,-ny);
			to = sp1.vertex;
		}
		this.connectCable(from,to);
		return true;
	}
	,isOutput: function(v) {
		var _g = v.type;
		switch(_g._hx_index) {
		case 0:
			var _g1 = _g.n.type;
			switch(_g1._hx_index) {
			case 0:
				return _g1.output;
			case 1:
				return _g1.output;
			case 2:
				return true;
			case 3:
				return _g1.io == true;
			}
			break;
		case 1:
			if(graph_SocketTypeTool.io(_g.s.type)) {
				return true;
			} else {
				return false;
			}
			break;
		case 2:
			return true;
		}
	}
	,isInput: function(v) {
		var _g = v.type;
		switch(_g._hx_index) {
		case 0:
			var _g1 = _g.n.type;
			switch(_g1._hx_index) {
			case 0:
				return _g1.input;
			case 1:
				return _g1.input;
			case 2:
				return true;
			case 3:
				return _g1.io == false;
			}
			break;
		case 1:
			if(graph_SocketTypeTool.io(_g.s.type)) {
				return false;
			} else {
				return true;
			}
			break;
		case 2:
			return true;
		}
	}
	,hasVisitedInDfs: function(v) {
		return v.tmpValForDfs == graph_Graph.dfsCount;
	}
	,dfs: function(onVisit,from,updateDfsCount) {
		if(updateDfsCount == null) {
			updateDfsCount = true;
		}
		if(updateDfsCount) {
			graph_Graph.dfsCount++;
		}
		if(onVisit == null || from == null || from.tmpValForDfs == graph_Graph.dfsCount) {
			return;
		}
		var vs = [];
		vs.push(from);
		while(vs.length > 0) {
			var v = vs.pop();
			v.tmpValForDfs = graph_Graph.dfsCount;
			if(!onVisit(v)) {
				continue;
			}
			var _g = 0;
			var _g1 = v.edges;
			while(_g < _g1.length) {
				var e = _g1[_g];
				++_g;
				if(e.v1.tmpValForDfs != graph_Graph.dfsCount) {
					e.v1.tmpValForDfs = graph_Graph.dfsCount;
					vs.push(e.v1);
				}
				if(e.v2.tmpValForDfs != graph_Graph.dfsCount) {
					e.v2.tmpValForDfs = graph_Graph.dfsCount;
					vs.push(e.v2);
				}
			}
		}
	}
	,isInSameCable: function(v1,v2) {
		var result = false;
		this.dfs(function(v) {
			if(v == v2) {
				result = true;
			}
			if(!result) {
				return v.type == graph_VertexType.Normal;
			} else {
				return false;
			}
		},v1);
		return result;
	}
	,createVertex: function(x,y,type,invM) {
		var v = new graph_Vertex(x,y,type,invM);
		this.world.addPoint(v.point);
		this.vertices.push(v);
		this.updateRequired = true;
		return v;
	}
	,createEdge: function(outVertex,inVertex,length) {
		if(length == null) {
			length = 0;
		}
		var e = new graph_Edge(outVertex,inVertex,length,outVertex.type._hx_index == 0 || inVertex.type._hx_index == 0);
		this.world.addSpring(e.spring);
		e.connect();
		this.edges.push(e);
		this.updateRequired = true;
		if(outVertex.type == graph_VertexType.Normal && outVertex.edges.length > 2) {
			throw new js__$Boot_HaxeError("!?!?!?");
		}
		if(inVertex.type == graph_VertexType.Normal && inVertex.edges.length > 2) {
			throw new js__$Boot_HaxeError("!?!?!?");
		}
		return e;
	}
	,updateConnections: function() {
		this.updateRequired = false;
		console.log("src/graph/Graph.hx:617:","computing connections");
		var _g = 0;
		var _g1 = this.edges;
		while(_g < _g1.length) {
			var e = _g1[_g];
			++_g;
			e.firstEdgeOf = null;
			e.lastEdgeOf = null;
		}
		var _g2 = 0;
		var _g3 = this.nodes;
		while(_g2 < _g3.length) {
			var _g21 = 0;
			var _g31 = _g3[_g2++].sockets;
			while(_g21 < _g31.length) {
				var s = _g31[_g21];
				++_g21;
				s.prevConnections = s.connections;
				s.connections = [];
			}
		}
		var _g4 = 0;
		var _g5 = this.nodes;
		while(_g4 < _g5.length) {
			var _g41 = 0;
			var _g51 = _g5[_g4++].sockets;
			while(_g41 < _g51.length) {
				var s1 = _g51[_g41];
				++_g41;
				if(graph_SocketTypeTool.io(s1.type) != true) {
					continue;
				}
				var sp = s1.phys;
				var edgeBackToNode = sp.edge;
				var _g42 = 0;
				var _g52 = sp.vertex.edges;
				while(_g42 < _g52.length) {
					var e1 = _g52[_g42];
					++_g42;
					if(e1 == edgeBackToNode) {
						continue;
					}
					var prevV = sp.vertex;
					var v = prevV != e1.v1 ? e1.v1 : e1.v2;
					var lastEdge = e1;
					var info = new graph_CableInfo();
					while(v != null && v.type == graph_VertexType.Normal) {
						v.followCable(prevV,info);
						prevV = v;
						v = info.vertex;
						lastEdge = info.edge;
					}
					if(v == null) {
						continue;
					}
					var _g43 = v.type;
					if(_g43._hx_index == 1) {
						var _g53 = _g43.s;
						if(graph_SocketTypeTool.io(_g53.type) != false) {
							throw new js__$Boot_HaxeError("socket type error");
						}
						var _g44 = 0;
						var _g54 = s1.connections;
						while(_g44 < _g54.length) {
							var c = _g54[_g44];
							++_g44;
							if(c.from == s1 && c.to == _g53) {
								throw new js__$Boot_HaxeError("duplicate connection found");
							}
						}
						var conn = new graph_SocketConnection(s1,_g53,e1,lastEdge);
						e1.firstEdgeOf = conn;
						lastEdge.lastEdgeOf = conn;
						s1.connections.push(conn);
						_g53.connections.push(conn);
					} else {
						throw new js__$Boot_HaxeError("cable connected to invalid vertex");
					}
				}
			}
		}
		var newConnections = [];
		var _g6 = 0;
		var _g7 = this.nodes;
		while(_g6 < _g7.length) {
			var _g61 = 0;
			var _g71 = _g7[_g6++].sockets;
			while(_g61 < _g71.length) {
				var s2 = _g71[_g61];
				++_g61;
				if(graph_SocketTypeTool.io(s2.type) != true) {
					continue;
				}
				var _g62 = 0;
				var _g72 = s2.connections;
				while(_g62 < _g72.length) {
					var s21 = _g72[_g62++].to;
					var oldIndex = graph_SocketConnection.indexOf(s2.prevConnections,s2,s21);
					if(oldIndex == -1) {
						newConnections.push(s2.id);
						newConnections.push(s21.id);
					} else {
						s2.prevConnections.splice(oldIndex,1);
					}
				}
			}
		}
		var _g8 = 0;
		var _g9 = this.nodes;
		while(_g8 < _g9.length) {
			var _g81 = 0;
			var _g91 = _g9[_g8++].sockets;
			while(_g81 < _g91.length) {
				var s3 = _g91[_g81];
				++_g81;
				if(graph_SocketTypeTool.io(s3.type) != true) {
					continue;
				}
				var _g82 = 0;
				var _g92 = s3.prevConnections;
				while(_g82 < _g92.length) this.listener.onSocketDisconnected(s3.id,_g92[_g82++].to.id);
			}
		}
		var _g10 = 0;
		var _g11 = newConnections.length >> 1;
		while(_g10 < _g11) {
			var i = _g10++;
			this.listener.onSocketConnected(newConnections[i << 1],newConnections[i << 1 | 1]);
		}
		var _g12 = 0;
		var _g13 = this.nodes;
		while(_g12 < _g13.length) _g13[_g12++].notifyUpdate();
	}
	,stepPhysics: function() {
		var i = -1;
		while(++i < this.edges.length) {
			var e = this.edges[i];
			if(!e.spring.stiff && e.spring.prevDist > 4.2) {
				var v1 = e.v1;
				var v2 = e.v2;
				var tmp = this.updateRequired;
				var v3 = this.createVertex((v1.point.x + v2.point.x) * 0.5,(v1.point.y + v2.point.y) * 0.5,graph_VertexType.Normal,2.);
				var c1 = e.firstEdgeOf;
				var c2 = e.lastEdgeOf;
				this.destroyEdge(e);
				var e1 = this.createEdge(v1,v3);
				var e2 = this.createEdge(v3,v2);
				if(c1 != null) {
					c1.firstEdge = e1;
					e1.firstEdgeOf = c1;
				}
				if(c2 != null) {
					c2.lastEdge = e2;
					e2.lastEdgeOf = c2;
				}
				this.updateRequired = tmp;
				--i;
			}
		}
		var i1 = -1;
		while(++i1 < this.vertices.length) {
			var v = this.vertices[i1];
			if(v.type._hx_index != 2) {
				continue;
			}
			if(v.edges.length == 0) {
				this.destroyVertex(v);
				--i1;
				continue;
			}
			if(v.edges.length == 1) {
				var e3 = v.edges[0];
				var other = e3.v1 == v ? e3.v2 : e3.v1;
				if(--v.life <= 0 || other.edges.length != 2 || other.type != graph_VertexType.Normal) {
					this.destroyVertex(v);
					--i1;
					continue;
				}
			}
			if(v.edges.length != 2) {
				continue;
			}
			var e11 = v.edges[0];
			var e21 = v.edges[1];
			if(e11.spring.stiff || e21.spring.stiff) {
				continue;
			}
			if(!(v == e11.v2 && v == e21.v1)) {
				if(v == e21.v2 && v == e11.v1) {
					var tmp1 = e11;
					e11 = e21;
					e21 = tmp1;
				} else {
					continue;
				}
			}
			var v11 = e11.v1;
			var v21 = e21.v2;
			var c11 = e11.firstEdgeOf;
			var c21 = e21.lastEdgeOf;
			if((v11.type._hx_index != 2 || v11.edges.length > 2) && (v21.type._hx_index != 2 || v21.edges.length > 2)) {
				continue;
			}
			if(e11.spring.prevDist + e21.spring.prevDist > 3.8) {
				continue;
			}
			var tmp2 = this.updateRequired;
			this.destroyVertex(v);
			var e4 = this.createEdge(v11,v21);
			if(c11 != null) {
				c11.firstEdge = e4;
				e4.firstEdgeOf = c11;
			}
			if(c21 != null) {
				c21.lastEdge = e4;
				e4.lastEdgeOf = c21;
			}
			this.updateRequired = tmp2;
			--i1;
		}
		var _g = 0;
		var _g1 = this.nodes;
		while(_g < _g1.length) {
			var n = _g1[_g];
			++_g;
			var toDestroy = null;
			var _g2 = 0;
			var _g11 = n.sockets;
			while(_g2 < _g11.length) {
				var s = _g11[_g2];
				++_g2;
				if(s.type._hx_index != 0) {
					continue;
				}
				if(s.phys.vertex.edges.length == 1) {
					if(toDestroy == null) {
						toDestroy = [];
					}
					toDestroy.push(s);
				}
			}
			if(toDestroy != null) {
				var _g21 = 0;
				while(_g21 < toDestroy.length) n.destroySocket(toDestroy[_g21++]);
			}
		}
		var i2 = -1;
		while(++i2 < this.nodes.length) {
			var n1 = this.nodes[i2];
			if(n1.type != graph_NodeType.Small) {
				continue;
			}
			var ins = 0;
			var outs = 0;
			var inV = null;
			var outV = null;
			var _g3 = 0;
			var _g12 = n1.sockets;
			while(_g3 < _g12.length) {
				var s1 = _g12[_g3];
				++_g3;
				if(graph_SocketTypeTool.io(s1.type)) {
					++outs;
					var sp = s1.phys;
					var res = null;
					var _g4 = 0;
					var _g13 = sp.vertex.edges;
					while(_g4 < _g13.length) {
						var e5 = _g13[_g4];
						++_g4;
						var v4 = sp.vertex != e5.v1 ? e5.v1 : e5.v2;
						if(v4.type._hx_index != 0) {
							res = v4;
							break;
						}
					}
					outV = res;
				} else {
					++ins;
					var sp1 = s1.phys;
					var res1 = null;
					var _g5 = 0;
					var _g14 = sp1.vertex.edges;
					while(_g5 < _g14.length) {
						var e6 = _g14[_g5];
						++_g5;
						var v5 = sp1.vertex != e6.v1 ? e6.v1 : e6.v2;
						if(v5.type._hx_index != 0) {
							res1 = v5;
							break;
						}
					}
					inV = res1;
				}
			}
			if(ins <= 1 && outs <= 1) {
				this.destroyNode(n1);
				if(inV != null && outV != null) {
					this.createEdge(inV,outV);
				}
				if(inV != null) {
					inV.vibrate(true);
				}
				if(outV != null) {
					outV.vibrate(true);
				}
				--i2;
				continue;
			}
		}
		if(this.updateRequired) {
			this.updateConnections();
		}
		var _g6 = 0;
		var _g15 = this.nodes;
		while(_g6 < _g15.length) {
			var _g7 = 0;
			var _g16 = _g15[_g6++].sockets;
			while(_g7 < _g16.length) _g16[_g7++].phys.computeDrawingPos();
		}
		var _g22 = 1;
		var _g31 = this.nodes.length;
		while(_g22 < _g31) {
			var i3 = _g22++;
			var _g23 = 0;
			while(_g23 < i3) {
				var n11 = this.nodes[i3];
				var n2 = this.nodes[_g23++];
				var n1p = n11.phys;
				var n2p = n2.phys;
				var v12 = n1p.vertex;
				var v22 = n2p.vertex;
				var invM1 = v12.point.invM;
				var invM2 = v22.point.invM;
				if(invM1 + invM2 == 0) {
					invM1 = 1;
					invM2 = 1;
				}
				var x1;
				var y1;
				var x2;
				var y2;
				var _g8 = v12.type;
				if(_g8._hx_index == 1) {
					var _g17 = _g8.s;
					x1 = _g17.phys.xForDrawing;
					y1 = _g17.phys.yForDrawing;
				} else {
					x1 = v12.point.x;
					y1 = v12.point.y;
				}
				var _g24 = v22.type;
				if(_g24._hx_index == 1) {
					var _g32 = _g24.s;
					x2 = _g32.phys.xForDrawing;
					y2 = _g32.phys.yForDrawing;
				} else {
					x2 = v22.point.x;
					y2 = v22.point.y;
				}
				var dx = x1 - x2;
				var dy = y1 - y2;
				var dist = Math.sqrt(dx * dx + dy * dy);
				var invDist = dist == 0 ? 0 : 1 / dist;
				var nx = dx * invDist;
				var ny = dy * invDist;
				var f = n1p.radius + n2p.radius + 1.0 - dist;
				f /= invM1 + invM2;
				f *= 0.1;
				if(f > 0) {
					v12.point.vx += f * nx * invM1;
					v12.point.vy += f * ny * invM1;
					v22.point.vx -= f * nx * invM2;
					v22.point.vy -= f * ny * invM2;
				}
				var _g25 = 0;
				var _g33 = n11.sockets;
				while(_g25 < _g33.length) {
					var s11 = _g33[_g25++];
					var _g26 = 0;
					var _g34 = n2.sockets;
					while(_g26 < _g34.length) {
						var s1p = s11.phys;
						var s2p = _g34[_g26++].phys;
						var v13 = s1p.vertex;
						var v23 = s2p.vertex;
						var invM11 = v13.point.invM;
						var invM21 = v23.point.invM;
						if(invM11 + invM21 == 0) {
							invM11 = 1;
							invM21 = 1;
						}
						var x11;
						var y11;
						var x21;
						var y21;
						var _g9 = v13.type;
						if(_g9._hx_index == 1) {
							var _g18 = _g9.s;
							x11 = _g18.phys.xForDrawing;
							y11 = _g18.phys.yForDrawing;
						} else {
							x11 = v13.point.x;
							y11 = v13.point.y;
						}
						var _g27 = v23.type;
						if(_g27._hx_index == 1) {
							var _g35 = _g27.s;
							x21 = _g35.phys.xForDrawing;
							y21 = _g35.phys.yForDrawing;
						} else {
							x21 = v23.point.x;
							y21 = v23.point.y;
						}
						var dx1 = x11 - x21;
						var dy1 = y11 - y21;
						var dist1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);
						var invDist1 = dist1 == 0 ? 0 : 1 / dist1;
						var nx1 = dx1 * invDist1;
						var ny1 = dy1 * invDist1;
						var f1 = s1p.radius + s2p.radius + 1.0 - dist1;
						f1 /= invM11 + invM21;
						f1 *= 0.1;
						if(f1 > 0) {
							v13.point.vx += f1 * nx1 * invM11;
							v13.point.vy += f1 * ny1 * invM11;
							v23.point.vx -= f1 * nx1 * invM21;
							v23.point.vy -= f1 * ny1 * invM21;
						}
					}
				}
			}
		}
		var _g41 = 0;
		var _g51 = this.nodes;
		while(_g41 < _g51.length) {
			var n12 = _g51[_g41++];
			var _g42 = 0;
			var _g52 = this.nodes;
			while(_g42 < _g52.length) {
				var _g43 = 0;
				var _g53 = _g52[_g42++].sockets;
				while(_g43 < _g53.length) {
					var n1p1 = n12.phys;
					var s2p1 = _g53[_g43++].phys;
					var v14 = n1p1.vertex;
					var v24 = s2p1.vertex;
					var invM12 = v14.point.invM;
					var invM22 = v24.point.invM;
					if(invM12 + invM22 == 0) {
						invM12 = 1;
						invM22 = 1;
					}
					var x12;
					var y12;
					var x22;
					var y22;
					var _g10 = v14.type;
					if(_g10._hx_index == 1) {
						var _g19 = _g10.s;
						x12 = _g19.phys.xForDrawing;
						y12 = _g19.phys.yForDrawing;
					} else {
						x12 = v14.point.x;
						y12 = v14.point.y;
					}
					var _g28 = v24.type;
					if(_g28._hx_index == 1) {
						var _g36 = _g28.s;
						x22 = _g36.phys.xForDrawing;
						y22 = _g36.phys.yForDrawing;
					} else {
						x22 = v24.point.x;
						y22 = v24.point.y;
					}
					var dx2 = x12 - x22;
					var dy2 = y12 - y22;
					var dist2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);
					var invDist2 = dist2 == 0 ? 0 : 1 / dist2;
					var nx2 = dx2 * invDist2;
					var ny2 = dy2 * invDist2;
					var f2 = n1p1.radius + s2p1.radius + 1.0 - dist2;
					f2 /= invM12 + invM22;
					f2 *= 0.1;
					if(f2 > 0) {
						v14.point.vx += f2 * nx2 * invM12;
						v14.point.vy += f2 * ny2 * invM12;
						v24.point.vx -= f2 * nx2 * invM22;
						v24.point.vy -= f2 * ny2 * invM22;
					}
				}
			}
		}
		var _g61 = 0;
		var _g71 = this.nodes;
		while(_g61 < _g71.length) {
			var n3 = _g71[_g61];
			++_g61;
			var _g62 = 1;
			var _g72 = n3.sockets.length;
			while(_g62 < _g72) {
				var i4 = _g62++;
				var _g63 = 0;
				while(_g63 < i4) {
					var s12 = n3.sockets[i4];
					var s2 = n3.sockets[_g63++];
					var s1p1 = s12.phys;
					var s2p2 = s2.phys;
					var v15 = s1p1.vertex;
					var v25 = s2p2.vertex;
					var strength = s12.type._hx_index == 1 || s2.type._hx_index == 1 ? 1 : 0.2;
					if(strength == null) {
						strength = 1.0;
					}
					var invM13 = v15.point.invM;
					var invM23 = v25.point.invM;
					if(invM13 + invM23 == 0) {
						invM13 = 1;
						invM23 = 1;
					}
					var x13;
					var y13;
					var x23;
					var y23;
					var _g20 = v15.type;
					if(_g20._hx_index == 1) {
						var _g110 = _g20.s;
						x13 = _g110.phys.xForDrawing;
						y13 = _g110.phys.yForDrawing;
					} else {
						x13 = v15.point.x;
						y13 = v15.point.y;
					}
					var _g29 = v25.type;
					if(_g29._hx_index == 1) {
						var _g37 = _g29.s;
						x23 = _g37.phys.xForDrawing;
						y23 = _g37.phys.yForDrawing;
					} else {
						x23 = v25.point.x;
						y23 = v25.point.y;
					}
					var dx3 = x13 - x23;
					var dy3 = y13 - y23;
					var dist3 = Math.sqrt(dx3 * dx3 + dy3 * dy3);
					var invDist3 = dist3 == 0 ? 0 : 1 / dist3;
					var nx3 = dx3 * invDist3;
					var ny3 = dy3 * invDist3;
					var f3 = (s1p1.radius + s2p2.radius + 1.0 - dist3) * strength;
					f3 /= invM13 + invM23;
					f3 *= 0.1;
					if(f3 > 0) {
						v15.point.vx += f3 * nx3 * invM13;
						v15.point.vy += f3 * ny3 * invM13;
						v25.point.vx -= f3 * nx3 * invM23;
						v25.point.vy -= f3 * ny3 * invM23;
					}
				}
			}
		}
		var _g81 = 0;
		var _g91 = this.vertices;
		while(_g81 < _g91.length) {
			var v6 = _g91[_g81];
			++_g81;
			if(v6.type != graph_VertexType.Normal) {
				continue;
			}
			var _g82 = 0;
			var _g92 = this.nodes;
			while(_g82 < _g92.length) {
				var np = _g92[_g82++].phys;
				var v26 = np.vertex;
				var invM14 = v6.point.invM;
				var invM24 = v26.point.invM;
				if(invM14 + invM24 == 0) {
					invM14 = 1;
					invM24 = 1;
				}
				var x14;
				var y14;
				var x24;
				var y24;
				var _g30 = v6.type;
				if(_g30._hx_index == 1) {
					var _g111 = _g30.s;
					x14 = _g111.phys.xForDrawing;
					y14 = _g111.phys.yForDrawing;
				} else {
					x14 = v6.point.x;
					y14 = v6.point.y;
				}
				var _g210 = v26.type;
				if(_g210._hx_index == 1) {
					var _g38 = _g210.s;
					x24 = _g38.phys.xForDrawing;
					y24 = _g38.phys.yForDrawing;
				} else {
					x24 = v26.point.x;
					y24 = v26.point.y;
				}
				var dx4 = x14 - x24;
				var dy4 = y14 - y24;
				var dist4 = Math.sqrt(dx4 * dx4 + dy4 * dy4);
				var invDist4 = dist4 == 0 ? 0 : 1 / dist4;
				var nx4 = dx4 * invDist4;
				var ny4 = dy4 * invDist4;
				var f4 = np.radius + 1.0 - dist4;
				f4 /= invM14 + invM24;
				f4 *= 0.1;
				if(f4 > 0) {
					v6.point.vx += f4 * nx4 * invM14;
					v6.point.vy += f4 * ny4 * invM14;
					v26.point.vx -= f4 * nx4 * invM24;
					v26.point.vy -= f4 * ny4 * invM24;
				}
			}
			var n4 = v6.edges.length;
			if(n4 <= 2) {
				continue;
			}
			var _g101 = 1;
			while(_g101 < n4) {
				var i5 = _g101++;
				var _g102 = 0;
				while(_g102 < i5) {
					var j = _g102++;
					var e7 = v6.edges[i5];
					var v16 = e7.v1 != v6 ? e7.v1 : e7.v2;
					var e8 = v6.edges[j];
					var v27 = e8.v1 != v6 ? e8.v1 : e8.v2;
					var invM15 = v16.point.invM;
					var invM25 = v27.point.invM;
					if(invM15 + invM25 == 0) {
						invM15 = 1;
						invM25 = 1;
					}
					var x15;
					var y15;
					var x25;
					var y25;
					var _g39 = v16.type;
					if(_g39._hx_index == 1) {
						var _g112 = _g39.s;
						x15 = _g112.phys.xForDrawing;
						y15 = _g112.phys.yForDrawing;
					} else {
						x15 = v16.point.x;
						y15 = v16.point.y;
					}
					var _g211 = v27.type;
					if(_g211._hx_index == 1) {
						var _g310 = _g211.s;
						x25 = _g310.phys.xForDrawing;
						y25 = _g310.phys.yForDrawing;
					} else {
						x25 = v27.point.x;
						y25 = v27.point.y;
					}
					var dx5 = x15 - x25;
					var dy5 = y15 - y25;
					var dist5 = Math.sqrt(dx5 * dx5 + dy5 * dy5);
					var invDist5 = dist5 == 0 ? 0 : 1 / dist5;
					var nx5 = dx5 * invDist5;
					var ny5 = dy5 * invDist5;
					var f5 = 6. - dist5;
					f5 /= invM15 + invM25;
					f5 *= 0.1;
					if(f5 > 0) {
						v16.point.vx += f5 * nx5 * invM15;
						v16.point.vy += f5 * ny5 * invM15;
						v27.point.vx -= f5 * nx5 * invM25;
						v27.point.vy -= f5 * ny5 * invM25;
					}
				}
			}
		}
		this.world.step();
	}
	,pick: function(x,y,flags,radius) {
		var minD = radius;
		var minV = null;
		var _g = 0;
		var _g1 = this.vertices;
		while(_g < _g1.length) {
			var v = _g1[_g];
			++_g;
			var vx = v.point.x;
			var vy = v.point.y;
			var r = 0;
			var _g2 = v.type;
			switch(_g2._hx_index) {
			case 0:
				if((flags & 1) == 0) {
					continue;
				}
				r = _g2.n.phys.radius;
				break;
			case 1:
				var _g21 = _g2.s;
				var _g3 = _g21.type;
				var tmp;
				switch(_g3._hx_index) {
				case 0:
					tmp = _g3.io ? 8 : 4;
					break;
				case 1:
					tmp = _g3.io ? 32 : 16;
					break;
				case 2:
					tmp = _g3.io ? 32 : 16;
					break;
				}
				if((flags & tmp) == 0) {
					continue;
				}
				var sp = _g21.phys;
				sp.computeDrawingPos();
				vx = sp.xForDrawing;
				vy = sp.yForDrawing;
				r = sp.radius;
				break;
			case 2:
				if((flags & 2) == 0) {
					continue;
				}
				r = 2.;
				break;
			}
			var dx = x - vx;
			var dy = y - vy;
			var dist = Math.sqrt(dx * dx + dy * dy);
			dist -= r;
			if(dist < minD) {
				minD = dist;
				minV = v;
			}
		}
		return minV;
	}
	,destroyVertex: function(v) {
		switch(v.type._hx_index) {
		case 0:
			throw new js__$Boot_HaxeError("cannot destroy node vertex");
		case 1:
			throw new js__$Boot_HaxeError("cannot destroy socket vertex");
		case 2:
			this.destroyVertexUnsafe(v);
			break;
		}
	}
	,destroyVertexUnsafe: function(v) {
		var es = v.edges.slice();
		var _g = 0;
		while(_g < es.length) this.destroyEdge(es[_g++]);
		this.world.removePoint(v.point);
		if(!HxOverrides.remove(this.vertices,v)) {
			throw new js__$Boot_HaxeError("couldn't remove vertex");
		}
		this.updateRequired = true;
	}
	,destroyEdge: function(e) {
		this.world.removeSpring(e.spring);
		e.disconnect();
		if(!HxOverrides.remove(this.edges,e)) {
			throw new js__$Boot_HaxeError("couldn't remove edge");
		}
		this.updateRequired = true;
	}
	,serialize: function() {
		this.updateConnections();
		var nodes = [];
		var _g = 0;
		var _g1 = this.nodes;
		while(_g < _g1.length) nodes.push(_g1[_g++].serialize());
		var connections = [];
		var _g2 = 0;
		var _g3 = this.nodes;
		while(_g2 < _g3.length) {
			var _g21 = 0;
			var _g31 = _g3[_g2++].sockets;
			while(_g21 < _g31.length) {
				var s = _g31[_g21];
				++_g21;
				if(graph_SocketTypeTool.io(s.type) == false) {
					continue;
				}
				var _g22 = 0;
				var _g32 = s.connections;
				while(_g22 < _g32.length) {
					var c = _g32[_g22];
					++_g22;
					var fromN = c.from.parent;
					var toN = c.to.parent;
					connections.push({ n1 : this.nodes.indexOf(fromN), s1 : fromN.sockets.indexOf(c.from), n2 : this.nodes.indexOf(toN), s2 : toN.sockets.indexOf(c.to)});
				}
			}
		}
		return { nodes : nodes, connections : connections};
	}
	,__class__: graph_Graph
};
var graph_GraphBoundingVolume = function(x,y,r) {
	this.x = x;
	this.y = y;
	this.r = r;
};
graph_GraphBoundingVolume.__name__ = true;
graph_GraphBoundingVolume.prototype = {
	__class__: graph_GraphBoundingVolume
};
var graph_Node = function(g,x,y,type,setting) {
	this.id = ++graph_Node.idCount;
	this.g = g;
	this.type = type;
	this.setting = setting;
	if(type._hx_index == 1) {
		this.moduleGraph = new graph_Graph(g.listener);
		this.moduleGraph.parent = g;
		this.moduleBoundaries = [];
	}
	this.phys = new graph_NodePhys(g,this,x,y);
	this.sockets = [];
	this.selected = false;
	this.selectingCount = 0;
};
graph_Node.__name__ = true;
graph_Node.serializeType = function(type) {
	switch(type._hx_index) {
	case 0:
		return { normal : { input : type.input, output : type.output}};
	case 1:
		return { module : { input : type.input, output : type.output}};
	case 2:
		return { small : 0};
	case 3:
		return { boundary : type.io};
	}
};
graph_Node.deserializeType = function(data) {
	var count = 0;
	if(data.normal != null) {
		count = 1;
	}
	if(data.module != null) {
		++count;
	}
	if(data.boundary != null) {
		++count;
	}
	if(data.small != null) {
		++count;
	}
	if(count != 1) {
		throw new js__$Boot_HaxeError("invalid node type data: " + Std.string(data));
	}
	if(data.normal != null) {
		return graph_NodeType.Normal(data.normal.input,data.normal.output);
	}
	if(data.module != null) {
		return graph_NodeType.Module(data.module.input,data.module.output);
	}
	if(data.boundary != null) {
		return graph_NodeType.Boundary(data.boundary);
	}
	if(data.small != null) {
		return graph_NodeType.Small;
	}
	throw new js__$Boot_HaxeError("!?");
};
graph_Node.prototype = {
	boundaryToNormal: function() {
		if(this.type._hx_index != 3) {
			throw new js__$Boot_HaxeError("not a boundary node");
		}
		this.phys.toSmall();
		this.type = graph_NodeType.Small;
		this.setting.name = "";
		this.setting.role = synth_NodeRole.Dupl;
		this.notifyUpdate();
	}
	,createSocket: function(type) {
		var ok;
		switch(type._hx_index) {
		case 0:
			if(type.io) {
				var _g = this.type;
				switch(_g._hx_index) {
				case 0:
					ok = _g.output;
					break;
				case 1:
					ok = _g.output;
					break;
				case 2:
					ok = true;
					break;
				case 3:
					ok = _g.io == true;
					break;
				}
			} else {
				var _g1 = this.type;
				switch(_g1._hx_index) {
				case 0:
					ok = _g1.input;
					break;
				case 1:
					ok = _g1.input;
					break;
				case 2:
					ok = true;
					break;
				case 3:
					ok = _g1.io == false;
					break;
				}
			}
			break;
		case 1:
			switch(this.type._hx_index) {
			case 0:
				ok = true;
				break;
			case 1:
				ok = false;
				break;
			case 2:
				ok = false;
				break;
			case 3:
				ok = false;
				break;
			}
			break;
		case 2:
			switch(this.type._hx_index) {
			case 0:
				ok = true;
				break;
			case 1:
				ok = true;
				break;
			case 2:
				ok = true;
				break;
			case 3:
				ok = true;
				break;
			}
			break;
		}
		if(!ok) {
			throw new js__$Boot_HaxeError("cannot create socket");
		}
		var reference;
		if(this.type._hx_index == 1) {
			switch(type._hx_index) {
			case 0:
				throw new js__$Boot_HaxeError("not implemented yet");
			case 1:
				throw new js__$Boot_HaxeError("module node cannot have param socket");
			case 2:
				reference = type.boundary;
				break;
			}
		} else {
			reference = this;
		}
		var s = new graph_Socket(this.g,this,type);
		this.sockets.push(s);
		this.g.listener.onSocketCreated(s.id,reference.id,reference != this ? graph_SocketType.Normal(graph_SocketTypeTool.io(s.type)) : s.type);
		return s;
	}
	,destroySocket: function(s) {
		var conns = s.connections.slice();
		var _g = 0;
		while(_g < conns.length) {
			var c = conns[_g];
			++_g;
			var s1 = c.from;
			var s2 = c.to;
			this.g.listener.onSocketDisconnected(s1.id,s2.id);
			HxOverrides.remove(s1.connections,c);
			HxOverrides.remove(s2.connections,c);
		}
		this.g.listener.onSocketDestroyed(s.id);
		this.g.destroyVertexUnsafe(s.phys.vertex);
		HxOverrides.remove(this.sockets,s);
	}
	,notifyUpdate: function() {
		if(this.type._hx_index != 1) {
			this.g.listener.onNodeUpdated(this.id);
		}
		if(this.type._hx_index == 2 || this.setting.role._hx_index == 2) {
			return;
		}
		var _g5 = this.setting.role;
		var nameLength = _g5._hx_index == 7 ? Std.string(_g5.num.get_value()).length : this.setting.name.length;
		if(this.type._hx_index == 3) {
			++nameLength;
		}
		this.phys.scale(nameLength > 3 ? 1.0 + (nameLength - 3) * 0.25 : 1.0);
	}
	,serialize: function(excludeNonParamSockets) {
		if(excludeNonParamSockets == null) {
			excludeNonParamSockets = false;
		}
		var _gthis = this;
		var sockets = [];
		var _g = 0;
		var _g1 = this.sockets;
		while(_g < _g1.length) {
			var s = _g1[_g];
			++_g;
			if(excludeNonParamSockets && s.type._hx_index == 0) {
				continue;
			}
			sockets.push(s.serialize());
		}
		var data = { x : Math.round(this.phys.vertex.point.x * 10000), y : Math.round(this.phys.vertex.point.y * 10000), type : graph_Node.serializeType(this.type), setting : this.setting.serialize(), sockets : sockets};
		if(this.type._hx_index == 1) {
			data.graph = this.moduleGraph.serialize();
			var _this = this.moduleBoundaries;
			var result = new Array(_this.length);
			var _g2 = 0;
			var _g11 = _this.length;
			while(_g2 < _g11) {
				var i = _g2++;
				result[i] = _gthis.moduleGraph.nodes.indexOf(_this[i]);
			}
			data.boundaries = result;
		}
		return data;
	}
	,__class__: graph_Node
};
var graph_NodeOption = function(name,onSelected,closeAfterSelection) {
	if(closeAfterSelection == null) {
		closeAfterSelection = false;
	}
	this.name = name;
	this.onSelected = function(n) {
		onSelected(n.setting);
		n.notifyUpdate();
		return;
	};
	this.closeAfterSelection = closeAfterSelection;
};
graph_NodeOption.__name__ = true;
graph_NodeOption.prototype = {
	__class__: graph_NodeOption
};
var graph_NodePhys = function(g,node,x,y) {
	this.node = node;
	this.vertex = g.createVertex(x,y,graph_VertexType.Node(node),0);
	this.radius = 12 * (node.type._hx_index == 2 ? 0.5 : node.setting.role._hx_index == 2 ? 3.0 : 1.0);
};
graph_NodePhys.__name__ = true;
graph_NodePhys.prototype = {
	toSmall: function() {
		this.vertex.point.invM = 0;
		this.scale(0.5);
	}
	,scale: function(s) {
		if(s == null) {
			s = 1.0;
		}
		this.radius = 12 * s;
		var _g = 0;
		var _g1 = this.node.sockets;
		while(_g < _g1.length) {
			var s1 = _g1[_g];
			++_g;
			s1.phys.edge.spring.length = this.radius + s1.phys.radius * 2;
		}
	}
	,__class__: graph_NodePhys
};
var graph_NodeSetting = function(name,role) {
	this.name = name;
	this.role = role;
};
graph_NodeSetting.__name__ = true;
graph_NodeSetting.serializeRole = function(role) {
	switch(role._hx_index) {
	case 0:
		return { frequency : 0};
	case 1:
		return { oscillator : role.type};
	case 2:
		return { destination : 0};
	case 3:
		return { delay : 0};
	case 4:
		return { filter : role.type};
	case 5:
		return { compressor : 0};
	case 6:
		var _g2 = role.env;
		return { envelope : { a : _g2.a, d : _g2.d, s : _g2.s, r : _g2.r}};
	case 7:
		return { number : role.num.get_value()};
	case 8:
		return { binOp : role.type};
	case 9:
		return { dupl : 0};
	case 10:
		return { none : 0};
	}
};
graph_NodeSetting.deserializeRole = function(data) {
	var count = 0;
	if(data.frequency != null) {
		count = 1;
	}
	if(data.oscillator != null) {
		++count;
	}
	if(data.destination != null) {
		++count;
	}
	if(data.delay != null) {
		++count;
	}
	if(data.filter != null) {
		++count;
	}
	if(data.compressor != null) {
		++count;
	}
	if(data.envelope != null) {
		++count;
	}
	if(data.number != null) {
		++count;
	}
	if(data.binOp != null) {
		++count;
	}
	if(data.dupl != null) {
		++count;
	}
	if(data.none != null) {
		++count;
	}
	if(count != 1) {
		throw new js__$Boot_HaxeError("invalid node role data: " + Std.string(data));
	}
	if(data.frequency != null) {
		return synth_NodeRole.Frequency;
	}
	if(data.oscillator != null) {
		return synth_NodeRole.Oscillator(data.oscillator);
	}
	if(data.destination != null) {
		return synth_NodeRole.Destination;
	}
	if(data.delay != null) {
		return synth_NodeRole.Delay;
	}
	if(data.filter != null) {
		return synth_NodeRole.Filter(data.filter);
	}
	if(data.compressor != null) {
		return synth_NodeRole.Compressor;
	}
	if(data.envelope != null) {
		return synth_NodeRole.Envelope(new synth_EnvelopeData(data.envelope.a,data.envelope.d,data.envelope.s,data.envelope.r));
	}
	if(data.number != null) {
		return synth_NodeRole.Number(new synth_NumberData(data.number));
	}
	if(data.binOp != null) {
		return synth_NodeRole.BinOp(data.binOp);
	}
	if(data.dupl != null) {
		return synth_NodeRole.Dupl;
	}
	if(data.none != null) {
		return synth_NodeRole.None;
	}
	throw new js__$Boot_HaxeError("!?");
};
graph_NodeSetting.deserialize = function(data) {
	return new graph_NodeSetting(data.name,graph_NodeSetting.deserializeRole(data.role));
};
graph_NodeSetting.prototype = {
	serialize: function() {
		return { name : this.name, role : graph_NodeSetting.serializeRole(this.role)};
	}
	,__class__: graph_NodeSetting
};
var graph_Socket = function(g,parent,type) {
	this.id = ++graph_Socket.idCount;
	this.prevConnections = [];
	this.connections = [];
	this.g = g;
	this.parent = parent;
	this.type = type;
	this.phys = new graph_SocketPhys(g,parent.phys,this);
};
graph_Socket.__name__ = true;
graph_Socket.serializeType = function(type,boundaries) {
	switch(type._hx_index) {
	case 0:
		return { normal : type.io};
	case 1:
		return { param : { io : type.io, name : type.name}};
	case 2:
		return { module : { io : type.io, boundaryNode : boundaries.indexOf(type.boundary)}};
	}
};
graph_Socket.deserializeType = function(data,boundaries) {
	var count = 0;
	if(data.normal != null) {
		count = 1;
	}
	if(data.param != null) {
		++count;
	}
	if(data.module != null) {
		++count;
	}
	if(count != 1) {
		throw new js__$Boot_HaxeError("invalid socket type data: " + Std.string(data));
	}
	if(data.normal != null) {
		return graph_SocketType.Normal(data.normal);
	}
	if(data.param != null) {
		return graph_SocketType.Param(data.param.io,data.param.name);
	}
	if(data.module != null) {
		return graph_SocketType.Module(data.module.io,boundaries[data.module.boundaryNode]);
	}
	throw new js__$Boot_HaxeError("!?");
};
graph_Socket.prototype = {
	serialize: function() {
		this.phys.computeDrawingPos();
		return { angle : Math.round(this.phys.getAngle() * 10000), type : graph_Socket.serializeType(this.type,this.parent.moduleBoundaries)};
	}
	,__class__: graph_Socket
};
var graph_SocketConnection = function(from,to,firstEdge,lastEdge) {
	this.from = from;
	this.to = to;
	this.firstEdge = firstEdge;
	this.lastEdge = lastEdge;
};
graph_SocketConnection.__name__ = true;
graph_SocketConnection.indexOf = function(array,from,to) {
	var _g = 0;
	var _g1 = array.length;
	while(_g < _g1) {
		var i = _g++;
		var c = array[i];
		if(c.from == from && c.to == to) {
			return i;
		}
	}
	return -1;
};
graph_SocketConnection.prototype = {
	other: function(s) {
		if(s != this.from) {
			return this.from;
		} else {
			return this.to;
		}
	}
	,nearestEdge: function(s) {
		if(s == this.from) {
			return this.firstEdge;
		} else {
			return this.lastEdge;
		}
	}
	,__class__: graph_SocketConnection
};
var graph_SocketPhys = function(g,nodePhys,socket) {
	this.socket = socket;
	this.nodePhys = nodePhys;
	var tmp;
	switch(socket.type._hx_index) {
	case 0:
		tmp = 2.0;
		break;
	case 1:
		tmp = 4.0;
		break;
	case 2:
		tmp = 4.0;
		break;
	}
	this.radius = tmp;
	this.vertex = g.createVertex(nodePhys.vertex.point.x + Math.random() * 2 - 1,nodePhys.vertex.point.y + Math.random() * 2 - 1,graph_VertexType.Socket(socket),0.2);
	this.edge = g.createEdge(nodePhys.vertex,this.vertex,nodePhys.radius + this.radius * 2);
	this.xForDrawing = 0;
	this.yForDrawing = 0;
	this.normalX = 0;
	this.normalY = 0;
	this.labels = null;
	this.labelText = "";
};
graph_SocketPhys.__name__ = true;
graph_SocketPhys.prototype = {
	setNormal: function(nx,ny) {
		this.vertex.point.x = this.nodePhys.vertex.point.x + nx * (this.nodePhys.radius + this.radius * 2);
		this.vertex.point.y = this.nodePhys.vertex.point.y + ny * (this.nodePhys.radius + this.radius * 2);
	}
	,getAngle: function() {
		this.computeDrawingPos();
		return Math.atan2(this.normalY,this.normalX);
	}
	,setAngle: function(angle) {
		this.setNormal(Math.cos(angle),Math.sin(angle));
	}
	,lookAt: function(x,y) {
		var dx = x - this.nodePhys.vertex.point.x;
		var dy = y - this.nodePhys.vertex.point.y;
		var d = Math.sqrt(dx * dx + dy * dy);
		var invD = d == 0 ? 0 : 1 / d;
		this.setNormal(dx * invD,dy * invD);
	}
	,computeDrawingPos: function() {
		var sx = this.vertex.point.x;
		var sy = this.vertex.point.y;
		var dx = sx - this.nodePhys.vertex.point.x;
		var dy = sy - this.nodePhys.vertex.point.y;
		var dist = Math.sqrt(dx * dx + dy * dy);
		var invDist = dist == 0 ? 0 : 1 / dist;
		this.normalX = dx * invDist;
		this.normalY = dy * invDist;
		this.xForDrawing = sx - this.normalX * this.radius;
		this.yForDrawing = sy - this.normalY * this.radius;
	}
	,__class__: graph_SocketPhys
};
var graph_SocketType = $hxEnums["graph.SocketType"] = { __ename__ : true, __constructs__ : ["Normal","Param","Module"]
	,Normal: ($_=function(io) { return {_hx_index:0,io:io,__enum__:"graph.SocketType",toString:$estr}; },$_.__params__ = ["io"],$_)
	,Param: ($_=function(io,name) { return {_hx_index:1,io:io,name:name,__enum__:"graph.SocketType",toString:$estr}; },$_.__params__ = ["io","name"],$_)
	,Module: ($_=function(io,boundary) { return {_hx_index:2,io:io,boundary:boundary,__enum__:"graph.SocketType",toString:$estr}; },$_.__params__ = ["io","boundary"],$_)
};
var graph_SocketTypeTool = function() { };
graph_SocketTypeTool.__name__ = true;
graph_SocketTypeTool.io = function(type) {
	switch(type._hx_index) {
	case 0:
		return type.io;
	case 1:
		return type.io;
	case 2:
		return type.io;
	}
};
var graph_Vertex = function(x,y,type,invM) {
	this.id = ++graph_Vertex.idCount;
	this.life = 60;
	this.type = type;
	this.point = new phys_Point(x,y,invM);
	var tmp;
	switch(type._hx_index) {
	case 0:
		tmp = 0.8;
		break;
	case 1:
		tmp = 0.8;
		break;
	case 2:
		tmp = 0.95;
		break;
	}
	this.point.damp = tmp;
	this.edges = [];
	this.tmpValForDfs = 0;
	this.tmpValForRendering = 0;
};
graph_Vertex.__name__ = true;
graph_Vertex.prototype = {
	vibrate: function(strong) {
		if(strong == null) {
			strong = false;
		}
		var ang = Math.random() * Math.PI * 2;
		var amp = strong ? 10 : 2;
		var fx = Math.cos(ang) * amp;
		var fy = Math.sin(ang) * amp;
		var _g = 0;
		var _g1 = this.edges;
		while(_g < _g1.length) {
			var e = _g1[_g];
			++_g;
			var v = this != e.v1 ? e.v1 : e.v2;
			if(v.type._hx_index != 0) {
				this.point.vx += fx;
				this.point.vy += fy;
				v.point.vx -= fx;
				v.point.vy -= fy;
				return;
			}
		}
	}
	,followCable: function(prev,out) {
		if(this.edges.length == 1) {
			var _this = this.edges[0];
			if((this != _this.v1 ? _this.v1 : _this.v2) != prev) {
				throw new js__$Boot_HaxeError("invalid prev point in cable");
			}
			out.vertex = null;
			out.edge = null;
			return false;
		}
		if(this.edges.length == 2) {
			var _this1 = this.edges[0];
			var v1 = this != _this1.v1 ? _this1.v1 : _this1.v2;
			var _this2 = this.edges[1];
			var v2 = this != _this2.v1 ? _this2.v1 : _this2.v2;
			if(v1 != prev && v2 != prev) {
				throw new js__$Boot_HaxeError("invalid prev point in cable");
			}
			if(v1 != prev) {
				out.vertex = v1;
				out.edge = this.edges[0];
			} else {
				out.vertex = v2;
				out.edge = this.edges[1];
			}
			return true;
		}
		throw new js__$Boot_HaxeError("cannot follow cable: edges=" + this.edges.length);
	}
	,__class__: graph_Vertex
};
var graph_VertexType = $hxEnums["graph.VertexType"] = { __ename__ : true, __constructs__ : ["Node","Socket","Normal"]
	,Node: ($_=function(n) { return {_hx_index:0,n:n,__enum__:"graph.VertexType",toString:$estr}; },$_.__params__ = ["n"],$_)
	,Socket: ($_=function(s) { return {_hx_index:1,s:s,__enum__:"graph.VertexType",toString:$estr}; },$_.__params__ = ["s"],$_)
	,Normal: {_hx_index:2,__enum__:"graph.VertexType",toString:$estr}
};
var graph_serial__$Fixed_Fixed_$Impl_$ = {};
graph_serial__$Fixed_Fixed_$Impl_$.__name__ = true;
graph_serial__$Fixed_Fixed_$Impl_$._new = function(val) {
	return val;
};
graph_serial__$Fixed_Fixed_$Impl_$.fromFloat = function(v) {
	return Math.round(v * 10000);
};
graph_serial__$Fixed_Fixed_$Impl_$.toFloat = function(this1) {
	return this1 / 10000;
};
var haxe_IMap = function() { };
haxe_IMap.__name__ = true;
haxe_IMap.__isInterface__ = true;
var haxe_ds_Either = $hxEnums["haxe.ds.Either"] = { __ename__ : true, __constructs__ : ["Left","Right"]
	,Left: ($_=function(v) { return {_hx_index:0,v:v,__enum__:"haxe.ds.Either",toString:$estr}; },$_.__params__ = ["v"],$_)
	,Right: ($_=function(v) { return {_hx_index:1,v:v,__enum__:"haxe.ds.Either",toString:$estr}; },$_.__params__ = ["v"],$_)
};
var haxe_ds_IntMap = function() {
	this.h = { };
};
haxe_ds_IntMap.__name__ = true;
haxe_ds_IntMap.__interfaces__ = [haxe_IMap];
haxe_ds_IntMap.prototype = {
	remove: function(key) {
		if(!this.h.hasOwnProperty(key)) {
			return false;
		}
		delete(this.h[key]);
		return true;
	}
	,keys: function() {
		var a = [];
		for( var key in this.h ) (this.h.hasOwnProperty(key) ? a.push(key | 0) : null);
		return HxOverrides.iter(a);
	}
	,iterator: function() {
		return { ref : this.h, it : this.keys(), hasNext : function() {
			return this.it.hasNext();
		}, next : function() {
			var i = this.it.next();
			return this.ref[i];
		}};
	}
	,__class__: haxe_ds_IntMap
};
var haxe_ds_ObjectMap = function() {
	this.h = { __keys__ : { }};
};
haxe_ds_ObjectMap.__name__ = true;
haxe_ds_ObjectMap.__interfaces__ = [haxe_IMap];
haxe_ds_ObjectMap.prototype = {
	set: function(key,value) {
		var id = key.__id__;
		if(id == null) {
			id = (key.__id__ = $global.$haxeUID++);
		}
		this.h[id] = value;
		this.h.__keys__[id] = key;
	}
	,remove: function(key) {
		var id = key.__id__;
		if(this.h.__keys__[id] == null) {
			return false;
		}
		delete(this.h[id]);
		delete(this.h.__keys__[id]);
		return true;
	}
	,keys: function() {
		var a = [];
		for( var key in this.h.__keys__ ) {
		if(this.h.hasOwnProperty(key)) {
			a.push(this.h.__keys__[key]);
		}
		}
		return HxOverrides.iter(a);
	}
	,__class__: haxe_ds_ObjectMap
};
var js__$Boot_HaxeError = function(val) {
	Error.call(this);
	this.val = val;
	if(Error.captureStackTrace) {
		Error.captureStackTrace(this,js__$Boot_HaxeError);
	}
};
js__$Boot_HaxeError.__name__ = true;
js__$Boot_HaxeError.__super__ = Error;
js__$Boot_HaxeError.prototype = $extend(Error.prototype,{
	__class__: js__$Boot_HaxeError
});
var js_Boot = function() { };
js_Boot.__name__ = true;
js_Boot.getClass = function(o) {
	if(o == null) {
		return null;
	} else if(((o) instanceof Array)) {
		return Array;
	} else {
		var cl = o.__class__;
		if(cl != null) {
			return cl;
		}
		var name = js_Boot.__nativeClassName(o);
		if(name != null) {
			return js_Boot.__resolveNativeClass(name);
		}
		return null;
	}
};
js_Boot.__string_rec = function(o,s) {
	if(o == null) {
		return "null";
	}
	if(s.length >= 5) {
		return "<...>";
	}
	var t = typeof(o);
	if(t == "function" && (o.__name__ || o.__ename__)) {
		t = "object";
	}
	switch(t) {
	case "function":
		return "<function>";
	case "object":
		if(o.__enum__) {
			var e = $hxEnums[o.__enum__];
			var n = e.__constructs__[o._hx_index];
			var con = e[n];
			if(con.__params__) {
				s = s + "\t";
				return n + "(" + ((function($this) {
					var $r;
					var _g = [];
					{
						var _g1 = 0;
						var _g2 = con.__params__;
						while(true) {
							if(!(_g1 < _g2.length)) {
								break;
							}
							var p = _g2[_g1];
							_g1 = _g1 + 1;
							_g.push(js_Boot.__string_rec(o[p],s));
						}
					}
					$r = _g;
					return $r;
				}(this))).join(",") + ")";
			} else {
				return n;
			}
		}
		if(((o) instanceof Array)) {
			var str = "[";
			s += "\t";
			var _g3 = 0;
			var _g11 = o.length;
			while(_g3 < _g11) {
				var i = _g3++;
				str += (i > 0 ? "," : "") + js_Boot.__string_rec(o[i],s);
			}
			str += "]";
			return str;
		}
		var tostr;
		try {
			tostr = o.toString;
		} catch( e1 ) {
			var e2 = ((e1) instanceof js__$Boot_HaxeError) ? e1.val : e1;
			return "???";
		}
		if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
			var s2 = o.toString();
			if(s2 != "[object Object]") {
				return s2;
			}
		}
		var str1 = "{\n";
		s += "\t";
		var hasp = o.hasOwnProperty != null;
		var k = null;
		for( k in o ) {
		if(hasp && !o.hasOwnProperty(k)) {
			continue;
		}
		if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
			continue;
		}
		if(str1.length != 2) {
			str1 += ", \n";
		}
		str1 += s + k + " : " + js_Boot.__string_rec(o[k],s);
		}
		s = s.substring(1);
		str1 += "\n" + s + "}";
		return str1;
	case "string":
		return o;
	default:
		return String(o);
	}
};
js_Boot.__interfLoop = function(cc,cl) {
	if(cc == null) {
		return false;
	}
	if(cc == cl) {
		return true;
	}
	if(Object.prototype.hasOwnProperty.call(cc,"__interfaces__")) {
		var intf = cc.__interfaces__;
		var _g = 0;
		var _g1 = intf.length;
		while(_g < _g1) {
			var i = intf[_g++];
			if(i == cl || js_Boot.__interfLoop(i,cl)) {
				return true;
			}
		}
	}
	return js_Boot.__interfLoop(cc.__super__,cl);
};
js_Boot.__instanceof = function(o,cl) {
	if(cl == null) {
		return false;
	}
	switch(cl) {
	case Array:
		return ((o) instanceof Array);
	case Bool:
		return typeof(o) == "boolean";
	case Dynamic:
		return o != null;
	case Float:
		return typeof(o) == "number";
	case Int:
		if(typeof(o) == "number") {
			return ((o | 0) === o);
		} else {
			return false;
		}
		break;
	case String:
		return typeof(o) == "string";
	default:
		if(o != null) {
			if(typeof(cl) == "function") {
				if(js_Boot.__downcastCheck(o,cl)) {
					return true;
				}
			} else if(typeof(cl) == "object" && js_Boot.__isNativeObj(cl)) {
				if(((o) instanceof cl)) {
					return true;
				}
			}
		} else {
			return false;
		}
		if(cl == Class ? o.__name__ != null : false) {
			return true;
		}
		if(cl == Enum ? o.__ename__ != null : false) {
			return true;
		}
		return o.__enum__ != null ? $hxEnums[o.__enum__] == cl : false;
	}
};
js_Boot.__downcastCheck = function(o,cl) {
	if(!((o) instanceof cl)) {
		if(cl.__isInterface__) {
			return js_Boot.__interfLoop(js_Boot.getClass(o),cl);
		} else {
			return false;
		}
	} else {
		return true;
	}
};
js_Boot.__cast = function(o,t) {
	if(o == null || js_Boot.__instanceof(o,t)) {
		return o;
	} else {
		throw new js__$Boot_HaxeError("Cannot cast " + Std.string(o) + " to " + Std.string(t));
	}
};
js_Boot.__nativeClassName = function(o) {
	var name = js_Boot.__toStr.call(o).slice(8,-1);
	if(name == "Object" || name == "Function" || name == "Math" || name == "JSON") {
		return null;
	}
	return name;
};
js_Boot.__isNativeObj = function(o) {
	return js_Boot.__nativeClassName(o) != null;
};
js_Boot.__resolveNativeClass = function(name) {
	return $global[name];
};
var phys_Point = function(x,y,invM) {
	if(invM == null) {
		invM = 1.0;
	}
	this.x = x;
	this.y = y;
	this.invM = invM;
	this.vx = 0;
	this.vy = 0;
	this.damp = 0.98;
};
phys_Point.__name__ = true;
phys_Point.prototype = {
	move: function() {
		this.x += this.vx;
		this.y += this.vy;
		this.vx *= this.damp;
		this.vy *= this.damp;
	}
	,__class__: phys_Point
};
var phys_Spring = function(p1,p2,length,stiff) {
	this.p1 = p1;
	this.p2 = p2;
	var dx = p1.x - p2.x;
	var dy = p1.y - p2.y;
	this.prevDist = Math.sqrt(dx * dx + dy * dy);
	this.length = length;
	this.stiff = stiff;
	this.totalImp = 0;
};
phys_Spring.__name__ = true;
phys_Spring.prototype = {
	preSolve: function() {
		var a = this.p1;
		var b = this.p2;
		var dx = a.x - b.x;
		var dy = a.y - b.y;
		this.prevDist = Math.sqrt(dx * dx + dy * dy);
		this.totalImp *= 0.5;
		var dx1 = this.p1.x + this.p1.vx - (this.p2.x + this.p2.vx);
		var dy1 = this.p1.y + this.p1.vy - (this.p2.y + this.p2.vy);
		var dist = Math.sqrt(dx1 * dx1 + dy1 * dy1);
		var invDist = dist > 0 ? 1 / dist : 0;
		var nx = dx1 * invDist;
		var ny = dy1 * invDist;
		this.p1.vx += nx * this.totalImp * this.p1.invM;
		this.p1.vy += ny * this.totalImp * this.p1.invM;
		this.p2.vx -= nx * this.totalImp * this.p2.invM;
		this.p2.vy -= ny * this.totalImp * this.p2.invM;
	}
	,solve: function() {
		var dx = this.p1.x + this.p1.vx - (this.p2.x + this.p2.vx);
		var dy = this.p1.y + this.p1.vy - (this.p2.y + this.p2.vy);
		var dist = Math.sqrt(dx * dx + dy * dy);
		var invDist = dist > 0 ? 1 / dist : 0;
		var nx = dx * invDist;
		var ny = dy * invDist;
		var imp = 1 / ((this.p1.invM + this.p2.invM) * (1.0 + (this.stiff ? 0 : 10.0))) * (this.length - dist) * 0.7;
		this.totalImp += imp;
		this.p1.vx += nx * imp * this.p1.invM;
		this.p1.vy += ny * imp * this.p1.invM;
		this.p2.vx -= nx * imp * this.p2.invM;
		this.p2.vy -= ny * imp * this.p2.invM;
	}
	,postSolve: function() {
	}
	,__class__: phys_Spring
};
var phys_World = function() {
	this.ps = [];
	this.ss = [];
};
phys_World.__name__ = true;
phys_World.prototype = {
	addPoint: function(p) {
		this.ps.push(p);
	}
	,removePoint: function(p) {
		return HxOverrides.remove(this.ps,p);
	}
	,addSpring: function(s) {
		this.ss.push(s);
	}
	,removeSpring: function(s) {
		return HxOverrides.remove(this.ss,s);
	}
	,step: function() {
		var _g = 0;
		var _g1 = this.ss;
		while(_g < _g1.length) _g1[_g++].preSolve();
		var _g2 = 0;
		var _g3 = this.ss;
		while(_g2 < _g3.length) _g3[_g2++].solve();
		var _g21 = 0;
		var _g31 = this.ss;
		while(_g21 < _g31.length) _g31[_g21++].solve();
		var _g22 = 0;
		var _g32 = this.ss;
		while(_g22 < _g32.length) _g32[_g22++].solve();
		var _g23 = 0;
		var _g33 = this.ss;
		while(_g23 < _g33.length) _g33[_g23++].solve();
		var _g24 = 0;
		var _g34 = this.ss;
		while(_g24 < _g34.length) _g34[_g24++].solve();
		var _g25 = 0;
		var _g35 = this.ss;
		while(_g25 < _g35.length) _g35[_g25++].solve();
		var _g26 = 0;
		var _g36 = this.ss;
		while(_g26 < _g36.length) _g36[_g26++].solve();
		var _g27 = 0;
		var _g37 = this.ss;
		while(_g27 < _g37.length) _g37[_g27++].solve();
		var _g28 = 0;
		var _g38 = this.ss;
		while(_g28 < _g38.length) ++_g28;
		var _g4 = 0;
		var _g5 = this.ps;
		while(_g4 < _g5.length) _g5[_g4++].move();
	}
	,__class__: phys_World
};
var pot_core_Pot = function(app,canvas) {
	this.app = app;
	this.canvas = canvas;
	this.timer = new pot_util_Timer($bind(this,this.frame));
};
pot_core_Pot.__name__ = true;
pot_core_Pot.prototype = {
	sizeMax: function(pixelScalingRatio) {
		if(pixelScalingRatio == null) {
			pixelScalingRatio = 1;
		}
		this.size(window.innerWidth,window.innerHeight,pixelScalingRatio);
	}
	,size: function(width,height,pixelScalingRatio) {
		if(pixelScalingRatio == null) {
			pixelScalingRatio = 1;
		}
		this.width = width;
		this.height = height;
		this.pixelScalingRatio = pixelScalingRatio;
		this.canvas.width = width * pixelScalingRatio;
		this.canvas.height = height * pixelScalingRatio;
		this.canvas.style.width = width + "px";
		this.canvas.style.height = height + "px";
	}
	,frameRate: function(fps) {
		if(fps == 0) {
			this.timer.setFrameRate(60);
			this.timer.setUseAnimationFrame(true);
		} else {
			this.timer.setFrameRate(fps);
		}
	}
	,start: function() {
		this.timer.start();
	}
	,stop: function() {
		this.timer.stop();
	}
	,frame: function() {
		if(this.app.input != null) {
			this.app.input.update();
		}
		this.app.loop();
		this.app.frameCount++;
	}
	,__class__: pot_core_Pot
};
var pot_input_Input = function(canvas,pot1) {
	this.mouse = new pot_input_Mouse();
	this.touches = new pot_input_TouchesData();
	this.keyboard = new pot_input_KeyboardData();
	this.scalingMode = 1;
	this.addEvents(canvas,pot1);
};
pot_input_Input.__name__ = true;
pot_input_Input.prototype = {
	addEvents: function(canvas,pot1) {
		this.mouse.addEvents(canvas,canvas,this,pot1);
		var this1 = this.touches;
		var canvas1 = canvas;
		var elem = canvas;
		var input = this;
		var pot2 = pot1;
		elem.addEventListener("touchstart",function(e) {
			if(e.cancelable) {
				e.preventDefault();
			}
			var touches = e.changedTouches;
			var _g = 0;
			var _g1 = touches.length;
			while(_g < _g1) {
				var rawTouch = touches[_g++];
				var touch = this1.getByRawId(rawTouch.identifier,true);
				var x = rawTouch.clientX - elem.getBoundingClientRect().left;
				var x1;
				switch(input.scalingMode) {
				case 0:
					x1 = canvas1.width / pot2.pixelScalingRatio / canvas1.clientWidth;
					break;
				case 1:
					x1 = canvas1.width / canvas1.clientWidth;
					break;
				}
				var x2 = x * x1;
				var y = rawTouch.clientY - elem.getBoundingClientRect().top;
				var y1;
				switch(input.scalingMode) {
				case 0:
					y1 = canvas1.height / pot2.pixelScalingRatio / canvas1.clientHeight;
					break;
				case 1:
					y1 = canvas1.height / canvas1.clientHeight;
					break;
				}
				touch.nx = x2;
				touch.ny = y * y1;
				touch.ntouching = true;
				touch.ntouching2 = true;
			}
			return;
		});
		elem.addEventListener("touchmove",function(e1) {
			if(e1.cancelable) {
				e1.preventDefault();
			}
			var touches1 = e1.changedTouches;
			var _g2 = 0;
			var _g11 = touches1.length;
			while(_g2 < _g11) {
				var rawTouch1 = touches1[_g2++];
				var touch1 = this1.getByRawId(rawTouch1.identifier);
				if(touch1 != null) {
					var x3 = rawTouch1.clientX - elem.getBoundingClientRect().left;
					var x4;
					switch(input.scalingMode) {
					case 0:
						x4 = canvas1.width / pot2.pixelScalingRatio / canvas1.clientWidth;
						break;
					case 1:
						x4 = canvas1.width / canvas1.clientWidth;
						break;
					}
					var x5 = x3 * x4;
					var y2 = rawTouch1.clientY - elem.getBoundingClientRect().top;
					var y3;
					switch(input.scalingMode) {
					case 0:
						y3 = canvas1.height / pot2.pixelScalingRatio / canvas1.clientHeight;
						break;
					case 1:
						y3 = canvas1.height / canvas1.clientHeight;
						break;
					}
					touch1.nx = x5;
					touch1.ny = y2 * y3;
				}
			}
			return;
		});
		var end = function(e2) {
			if(e2.cancelable) {
				e2.preventDefault();
			}
			var touches2 = e2.changedTouches;
			var _g3 = 0;
			var _g12 = touches2.length;
			while(_g3 < _g12) {
				var rawTouch2 = touches2[_g3++];
				var touch2 = this1.getByRawId(rawTouch2.identifier);
				if(touch2 != null) {
					var x6 = rawTouch2.clientX - elem.getBoundingClientRect().left;
					var x7;
					switch(input.scalingMode) {
					case 0:
						x7 = canvas1.width / pot2.pixelScalingRatio / canvas1.clientWidth;
						break;
					case 1:
						x7 = canvas1.width / canvas1.clientWidth;
						break;
					}
					var x8 = x6 * x7;
					var y4 = rawTouch2.clientY - elem.getBoundingClientRect().top;
					var y5;
					switch(input.scalingMode) {
					case 0:
						y5 = canvas1.height / pot2.pixelScalingRatio / canvas1.clientHeight;
						break;
					case 1:
						y5 = canvas1.height / canvas1.clientHeight;
						break;
					}
					touch2.nx = x8;
					touch2.ny = y4 * y5;
					touch2.ntouching = false;
				}
			}
			return;
		};
		elem.addEventListener("touchend",end);
		elem.addEventListener("touchcancel",end);
		var this2 = this.keyboard;
		var elem1 = window.document.body;
		elem1.addEventListener("keydown",function(e3) {
			var code = e3.keyCode;
			if(code < 112 || code > 135) {
				if(e3.cancelable) {
					e3.preventDefault();
				}
			}
			if(!this2.keys.h.hasOwnProperty(code)) {
				this2.keys.h[code] = new pot_input_Key();
			}
			this2.keys.h[code].press();
			return;
		});
		elem1.addEventListener("keyup",function(e4) {
			var code1 = e4.keyCode;
			if(e4.keyCode < 112 || e4.keyCode > 135) {
				if(e4.cancelable) {
					e4.preventDefault();
				}
			}
			if(!this2.keys.h.hasOwnProperty(code1)) {
				this2.keys.h[code1] = new pot_input_Key();
			}
			this2.keys.h[code1].release();
			return;
		});
	}
	,update: function() {
		this.mouse.update();
		var this1 = this.touches;
		var i = 0;
		while(i < this1.touches.length) {
			var touch = this1.touches[i];
			if(!touch.ptouching && !touch.touching && !touch.ntouching) {
				HxOverrides.remove(this1.touches,touch);
			} else {
				touch.update();
				++i;
			}
		}
		var key = this.keyboard.keys.iterator();
		while(key.hasNext()) key.next().update();
	}
	,__class__: pot_input_Input
};
var pot_input_InputTools = function() { };
pot_input_InputTools.__name__ = true;
var pot_input_Key = function() {
	this.down = false;
	this.pdown = false;
	this.ndown = false;
	this.ndown2 = false;
	this.ddown = 0;
};
pot_input_Key.__name__ = true;
pot_input_Key.prototype = {
	press: function() {
		this.ndown = true;
		this.ndown2 = true;
	}
	,release: function() {
		this.ndown = false;
	}
	,update: function() {
		this.pdown = this.down;
		this.down = this.ndown || this.ndown2;
		this.ndown2 = false;
		this.ddown = (this.down ? 1 : 0) - (this.pdown ? 1 : 0);
	}
	,__class__: pot_input_Key
};
var pot_input__$Keyboard_Keyboard_$Impl_$ = {};
pot_input__$Keyboard_Keyboard_$Impl_$.__name__ = true;
pot_input__$Keyboard_Keyboard_$Impl_$._new = function() {
	return new pot_input_KeyboardData();
};
pot_input__$Keyboard_Keyboard_$Impl_$.get = function(this1,code) {
	if(!this1.keys.h.hasOwnProperty(code)) {
		this1.keys.h[code] = new pot_input_Key();
	}
	return this1.keys.h[code];
};
pot_input__$Keyboard_Keyboard_$Impl_$.getNum = function(this1,index) {
	var i = 48 + index;
	if(!this1.keys.h.hasOwnProperty(i)) {
		this1.keys.h[i] = new pot_input_Key();
	}
	return this1.keys.h[i];
};
pot_input__$Keyboard_Keyboard_$Impl_$.addEvents = function(this1,canvas,elem) {
	elem.addEventListener("keydown",function(e) {
		var code = e.keyCode;
		if(code < 112 || code > 135) {
			if(e.cancelable) {
				e.preventDefault();
			}
		}
		if(!this1.keys.h.hasOwnProperty(code)) {
			this1.keys.h[code] = new pot_input_Key();
		}
		this1.keys.h[code].press();
		return;
	});
	elem.addEventListener("keyup",function(e1) {
		var code1 = e1.keyCode;
		if(e1.keyCode < 112 || e1.keyCode > 135) {
			if(e1.cancelable) {
				e1.preventDefault();
			}
		}
		if(!this1.keys.h.hasOwnProperty(code1)) {
			this1.keys.h[code1] = new pot_input_Key();
		}
		this1.keys.h[code1].release();
		return;
	});
};
pot_input__$Keyboard_Keyboard_$Impl_$.update = function(this1) {
	var key = this1.keys.iterator();
	while(key.hasNext()) key.next().update();
};
var pot_input_KeyboardData = function() {
	this.keys = new haxe_ds_IntMap();
};
pot_input_KeyboardData.__name__ = true;
pot_input_KeyboardData.prototype = {
	__class__: pot_input_KeyboardData
};
var pot_input_Mouse = function() {
	this.px = 0;
	this.py = 0;
	this.x = 0;
	this.y = 0;
	this.nx = 0;
	this.ny = 0;
	this.dx = 0;
	this.dy = 0;
	this.pleft = false;
	this.pmiddle = false;
	this.pright = false;
	this.left = false;
	this.middle = false;
	this.right = false;
	this.nleft = false;
	this.nmiddle = false;
	this.nright = false;
	this.dleft = 0;
	this.dmiddle = 0;
	this.dright = 0;
};
pot_input_Mouse.__name__ = true;
pot_input_Mouse.prototype = {
	addEvents: function(canvas,elem,input,pot1) {
		var _gthis = this;
		elem.addEventListener("mousedown",function(e) {
			if(e.cancelable) {
				e.preventDefault();
			}
			switch(e.button) {
			case 0:
				_gthis.nleft = true;
				_gthis.nleft2 = true;
				break;
			case 1:
				_gthis.nmiddle = true;
				_gthis.nmiddle2 = true;
				break;
			case 2:
				_gthis.nright = true;
				_gthis.nright2 = true;
				break;
			}
			var tmp = e.clientX - elem.getBoundingClientRect().left;
			var tmp1;
			switch(input.scalingMode) {
			case 0:
				tmp1 = canvas.width / pot1.pixelScalingRatio / canvas.clientWidth;
				break;
			case 1:
				tmp1 = canvas.width / canvas.clientWidth;
				break;
			}
			_gthis.nx = tmp * tmp1;
			var tmp2 = e.clientY - elem.getBoundingClientRect().top;
			var tmp3;
			switch(input.scalingMode) {
			case 0:
				tmp3 = canvas.height / pot1.pixelScalingRatio / canvas.clientHeight;
				break;
			case 1:
				tmp3 = canvas.height / canvas.clientHeight;
				break;
			}
			return _gthis.ny = tmp2 * tmp3;
		});
		elem.addEventListener("mouseup",function(e1) {
			if(e1.cancelable) {
				e1.preventDefault();
			}
			switch(e1.button) {
			case 0:
				_gthis.nleft = false;
				break;
			case 1:
				_gthis.nmiddle = false;
				break;
			case 2:
				_gthis.nright = false;
				break;
			}
			var tmp4 = e1.clientX - elem.getBoundingClientRect().left;
			var tmp5;
			switch(input.scalingMode) {
			case 0:
				tmp5 = canvas.width / pot1.pixelScalingRatio / canvas.clientWidth;
				break;
			case 1:
				tmp5 = canvas.width / canvas.clientWidth;
				break;
			}
			_gthis.nx = tmp4 * tmp5;
			var tmp6 = e1.clientY - elem.getBoundingClientRect().top;
			var tmp7;
			switch(input.scalingMode) {
			case 0:
				tmp7 = canvas.height / pot1.pixelScalingRatio / canvas.clientHeight;
				break;
			case 1:
				tmp7 = canvas.height / canvas.clientHeight;
				break;
			}
			return _gthis.ny = tmp6 * tmp7;
		});
		elem.addEventListener("mousemove",function(e2) {
			var tmp8 = e2.clientX - elem.getBoundingClientRect().left;
			var tmp9;
			switch(input.scalingMode) {
			case 0:
				tmp9 = canvas.width / pot1.pixelScalingRatio / canvas.clientWidth;
				break;
			case 1:
				tmp9 = canvas.width / canvas.clientWidth;
				break;
			}
			_gthis.nx = tmp8 * tmp9;
			var tmp10 = e2.clientY - elem.getBoundingClientRect().top;
			var tmp11;
			switch(input.scalingMode) {
			case 0:
				tmp11 = canvas.height / pot1.pixelScalingRatio / canvas.clientHeight;
				break;
			case 1:
				tmp11 = canvas.height / canvas.clientHeight;
				break;
			}
			return _gthis.ny = tmp10 * tmp11;
		});
		elem.addEventListener("contextmenu",function(e3) {
			e3.preventDefault();
			return;
		});
	}
	,update: function() {
		this.px = this.x;
		this.py = this.y;
		this.x = this.nx;
		this.y = this.ny;
		this.dx = this.x - this.px;
		this.dy = this.y - this.py;
		this.pleft = this.left;
		this.pmiddle = this.middle;
		this.pright = this.right;
		this.left = this.nleft || this.nleft2;
		this.middle = this.nmiddle || this.nmiddle2;
		this.right = this.nright || this.nright2;
		this.nleft2 = false;
		this.nmiddle2 = false;
		this.nright2 = false;
		this.dleft = (this.left ? 1 : 0) - (this.pleft ? 1 : 0);
		this.dmiddle = (this.middle ? 1 : 0) - (this.pmiddle ? 1 : 0);
		this.dright = (this.right ? 1 : 0) - (this.pright ? 1 : 0);
	}
	,__class__: pot_input_Mouse
};
var pot_input_Touch = function() {
	this.px = 0;
	this.py = 0;
	this.x = 0;
	this.y = 0;
	this.nx = 0;
	this.ny = 0;
	this.dx = 0;
	this.dy = 0;
	this.ptouching = false;
	this.touching = false;
	this.ntouching = false;
	this.ntouching2 = false;
	this.dtouching = 0;
	this.rawId = 0;
};
pot_input_Touch.__name__ = true;
pot_input_Touch.prototype = {
	update: function() {
		this.px = this.x;
		this.py = this.y;
		this.x = this.nx;
		this.y = this.ny;
		this.dx = this.x - this.px;
		this.dy = this.y - this.py;
		this.ptouching = this.touching;
		this.touching = this.ntouching || this.ntouching2;
		this.ntouching2 = false;
		this.dtouching = (this.touching ? 1 : 0) - (this.ptouching ? 1 : 0);
	}
	,__class__: pot_input_Touch
};
var pot_input__$Touches_Touches_$Impl_$ = {};
pot_input__$Touches_Touches_$Impl_$.__name__ = true;
pot_input__$Touches_Touches_$Impl_$._new = function() {
	return new pot_input_TouchesData();
};
pot_input__$Touches_Touches_$Impl_$.get_length = function(this1) {
	return this1.touches.length;
};
pot_input__$Touches_Touches_$Impl_$.get = function(this1,index) {
	return this1.touches[index];
};
pot_input__$Touches_Touches_$Impl_$.addEvents = function(this1,canvas,elem,input,pot1) {
	elem.addEventListener("touchstart",function(e) {
		if(e.cancelable) {
			e.preventDefault();
		}
		var touches = e.changedTouches;
		var _g = 0;
		var _g1 = touches.length;
		while(_g < _g1) {
			var rawTouch = touches[_g++];
			var touch = this1.getByRawId(rawTouch.identifier,true);
			var x = rawTouch.clientX - elem.getBoundingClientRect().left;
			var x1;
			switch(input.scalingMode) {
			case 0:
				x1 = canvas.width / pot1.pixelScalingRatio / canvas.clientWidth;
				break;
			case 1:
				x1 = canvas.width / canvas.clientWidth;
				break;
			}
			var x2 = x * x1;
			var y = rawTouch.clientY - elem.getBoundingClientRect().top;
			var y1;
			switch(input.scalingMode) {
			case 0:
				y1 = canvas.height / pot1.pixelScalingRatio / canvas.clientHeight;
				break;
			case 1:
				y1 = canvas.height / canvas.clientHeight;
				break;
			}
			touch.nx = x2;
			touch.ny = y * y1;
			touch.ntouching = true;
			touch.ntouching2 = true;
		}
		return;
	});
	elem.addEventListener("touchmove",function(e1) {
		if(e1.cancelable) {
			e1.preventDefault();
		}
		var touches1 = e1.changedTouches;
		var _g2 = 0;
		var _g11 = touches1.length;
		while(_g2 < _g11) {
			var rawTouch1 = touches1[_g2++];
			var touch1 = this1.getByRawId(rawTouch1.identifier);
			if(touch1 != null) {
				var x3 = rawTouch1.clientX - elem.getBoundingClientRect().left;
				var x4;
				switch(input.scalingMode) {
				case 0:
					x4 = canvas.width / pot1.pixelScalingRatio / canvas.clientWidth;
					break;
				case 1:
					x4 = canvas.width / canvas.clientWidth;
					break;
				}
				var x5 = x3 * x4;
				var y2 = rawTouch1.clientY - elem.getBoundingClientRect().top;
				var y3;
				switch(input.scalingMode) {
				case 0:
					y3 = canvas.height / pot1.pixelScalingRatio / canvas.clientHeight;
					break;
				case 1:
					y3 = canvas.height / canvas.clientHeight;
					break;
				}
				touch1.nx = x5;
				touch1.ny = y2 * y3;
			}
		}
		return;
	});
	var end = function(e2) {
		if(e2.cancelable) {
			e2.preventDefault();
		}
		var touches2 = e2.changedTouches;
		var _g3 = 0;
		var _g12 = touches2.length;
		while(_g3 < _g12) {
			var rawTouch2 = touches2[_g3++];
			var touch2 = this1.getByRawId(rawTouch2.identifier);
			if(touch2 != null) {
				var x6 = rawTouch2.clientX - elem.getBoundingClientRect().left;
				var x7;
				switch(input.scalingMode) {
				case 0:
					x7 = canvas.width / pot1.pixelScalingRatio / canvas.clientWidth;
					break;
				case 1:
					x7 = canvas.width / canvas.clientWidth;
					break;
				}
				var x8 = x6 * x7;
				var y4 = rawTouch2.clientY - elem.getBoundingClientRect().top;
				var y5;
				switch(input.scalingMode) {
				case 0:
					y5 = canvas.height / pot1.pixelScalingRatio / canvas.clientHeight;
					break;
				case 1:
					y5 = canvas.height / canvas.clientHeight;
					break;
				}
				touch2.nx = x8;
				touch2.ny = y4 * y5;
				touch2.ntouching = false;
			}
		}
		return;
	};
	elem.addEventListener("touchend",end);
	elem.addEventListener("touchcancel",end);
};
pot_input__$Touches_Touches_$Impl_$.update = function(this1) {
	var i = 0;
	while(i < this1.touches.length) {
		var touch = this1.touches[i];
		if(!touch.ptouching && !touch.touching && !touch.ntouching) {
			HxOverrides.remove(this1.touches,touch);
		} else {
			touch.update();
			++i;
		}
	}
};
var pot_input_TouchesData = function() {
	this.touches = [];
};
pot_input_TouchesData.__name__ = true;
pot_input_TouchesData.prototype = {
	getByRawId: function(rawId,create) {
		if(create == null) {
			create = false;
		}
		var _g = 0;
		var _g1 = this.touches;
		while(_g < _g1.length) {
			var t = _g1[_g];
			++_g;
			if(t.rawId == rawId) {
				return t;
			}
		}
		if(create) {
			return this.newTouch(rawId);
		} else {
			return null;
		}
	}
	,newTouch: function(rawId) {
		var minId = 0;
		while(true) {
			var tmp = minId;
			var _g = 0;
			var _g1 = this.touches;
			while(_g < _g1.length) if(_g1[_g++].id == minId) {
				++minId;
			}
			if(tmp == minId) {
				break;
			}
		}
		var touch = new pot_input_Touch();
		touch.rawId = rawId;
		touch.id = minId;
		this.touches.push(touch);
		return touch;
	}
	,__class__: pot_input_TouchesData
};
var pot_util_Timer = function(frame) {
	this.frame = frame;
	this.targetSleep = 16.666666666666668;
	this.useAnimationFrame = false;
};
pot_util_Timer.__name__ = true;
pot_util_Timer.prototype = {
	start: function() {
		if(this.running) {
			return;
		}
		this.nextTime = Date.now();
		this.running = true;
		window.setTimeout($bind(this,this.loop),0);
	}
	,stop: function() {
		if(!this.running) {
			return;
		}
		this.running = false;
	}
	,setFrameRate: function(frameRate) {
		this.targetSleep = 1000 / frameRate;
	}
	,setUseAnimationFrame: function(useAnimationFrame) {
		this.useAnimationFrame = useAnimationFrame;
	}
	,loop: function(arg) {
		if(!this.running) {
			return;
		}
		this.frame();
		var currentTime = Date.now();
		this.nextTime += this.targetSleep;
		if(this.nextTime < currentTime + 5) {
			this.nextTime = currentTime + 5;
		}
		var sleep = this.nextTime - currentTime + 0.5 | 0;
		if(this.useAnimationFrame) {
			window.requestAnimationFrame($bind(this,this.loop));
		} else {
			window.setTimeout($bind(this,this.loop),sleep);
		}
	}
	,now: function() {
		return Date.now();
	}
	,__class__: pot_util_Timer
};
var render_Renderer = function(canvas) {
	this.touchingCount = 0;
	this.canvas = canvas;
	this.view = new render_View();
	this.c2d = canvas.getContext("2d",null);
	this.canvasCenterHeightRatio = 0.4;
	this.waveData = [];
};
render_Renderer.__name__ = true;
render_Renderer.prototype = {
	context: function() {
		return this.c2d;
	}
	,render: function(graph) {
		var _gthis = this;
		if(graph.updateRequired) {
			graph.updateConnections();
		}
		this.c2d.fillStyle = "rgba(" + (255.0 | 0) + "," + (255.0 | 0) + "," + (255.0 | 0) + "," + 1.0 + ")";
		this.c2d.fillRect(0,0,this.canvas.width,this.canvas.height);
		var f = function() {
			_gthis.drawGraph(graph);
			return;
		};
		var _gthis1 = this;
		this.c2d.lineCap = "round";
		this.c2d.textBaseline = "middle";
		this.c2d.font = "bold 10px \"Courier New\"";
		var x = this.canvas.width * 0.5;
		var y = this.canvas.height * this.canvasCenterHeightRatio;
		this.c2d.save();
		this.c2d.translate(x,y);
		_gthis1.c2d.scale(_gthis1.view.scale,_gthis1.view.scale);
		_gthis1.c2d.translate(-_gthis1.view.centerX,-_gthis1.view.centerY);
		f();
		this.c2d.restore();
	}
	,renderTouch: function(canvasX,canvasY,touching) {
		var _gthis = this;
		var x = (canvasX - this.canvas.width * 0.5) / this.view.scale + this.view.centerX;
		var y = (canvasY - this.canvas.height * this.canvasCenterHeightRatio) / this.view.scale + this.view.centerY;
		if(touching) {
			this.touchingCount++;
		} else {
			if(this.touchingCount > 0) {
				this.touchingCount++;
			}
			if(this.touchingCount % 12 == 0) {
				this.touchingCount = 0;
			}
		}
		var t = this.touchingCount % 12 / 12;
		var strokeR = (1 - (1 - t) * (1 - t)) * 10;
		var strokeA = 1 - t;
		var f = function() {
			if(touching) {
				_gthis.c2d.fillStyle = "rgba(" + (0. | 0) + "," + (0. | 0) + "," + (0. | 0) + "," + 1.0 + ")";
				_gthis.c2d.beginPath();
				_gthis.c2d.arc(x,y,3,0,6.2831853071795862);
				_gthis.c2d.fill();
			}
			if(_gthis.touchingCount > 0) {
				_gthis.c2d.lineWidth = 3;
				var a = strokeA;
				if(a == null) {
					a = 1.0;
				}
				_gthis.c2d.strokeStyle = "rgba(" + (0. | 0) + "," + (0. | 0) + "," + (0. | 0) + "," + a + ")";
				_gthis.c2d.beginPath();
				_gthis.c2d.arc(x,y,strokeR,0,6.2831853071795862);
				_gthis.c2d.stroke();
			}
			return;
		};
		var _gthis1 = this;
		this.c2d.lineCap = "round";
		this.c2d.textBaseline = "middle";
		this.c2d.font = "bold 10px \"Courier New\"";
		var x1 = this.canvas.width * 0.5;
		var y1 = this.canvas.height * this.canvasCenterHeightRatio;
		this.c2d.save();
		this.c2d.translate(x1,y1);
		_gthis1.c2d.scale(_gthis1.view.scale,_gthis1.view.scale);
		_gthis1.c2d.translate(-_gthis1.view.centerX,-_gthis1.view.centerY);
		f();
		this.c2d.restore();
	}
	,renderKeyboard: function(offsetX,offsetY,width,height,text,touchCanvasX,touchCanvasY,touching) {
		var _gthis = this;
		var result = -1;
		this.c2d.save();
		this.c2d.translate(offsetX,offsetY);
		(function() {
			touchCanvasX -= offsetX;
			touchCanvasY -= offsetY;
			var stroke = 1.5 * _gthis.view.scale;
			var keyWidth = 24 * _gthis.view.scale;
			var numKeys = Math.ceil((width - stroke) / keyWidth);
			keyWidth = (width - stroke) / numKeys;
			_gthis.c2d.fillStyle = "rgba(" + (0. | 0) + "," + (0. | 0) + "," + (0. | 0) + "," + 1.0 + ")";
			_gthis.c2d.fillRect(0,0,stroke,height);
			var blackKeyExists = [true,true,false,true,true,true,false];
			var whiteIndex = -1;
			var blackIndex = -1;
			var _g = 0;
			while(_g < numKeys) {
				var i = _g++;
				var x = stroke + keyWidth * i;
				if(touchCanvasX > x && touchCanvasX < x + keyWidth - stroke && touchCanvasY > stroke && touchCanvasY < height - stroke) {
					whiteIndex = i;
				}
			}
			var _g2 = 0;
			var _g3 = numKeys - 1;
			while(_g2 < _g3) {
				var i1 = _g2++;
				if(blackKeyExists[i1 % blackKeyExists.length]) {
					var dx = stroke + keyWidth * (i1 + 1) - keyWidth * 0.6 * 0.5 + keyWidth * 0.6 * 0.5 - touchCanvasX;
					if((dx < 0 ? -dx : dx) < keyWidth * 0.5 * 0.6 * 1.5 && touchCanvasY > stroke && touchCanvasY < height * 0.5 - stroke) {
						blackIndex = i1;
					}
				}
			}
			if(blackIndex != -1) {
				whiteIndex = -1;
			}
			var _g4 = 0;
			while(_g4 < numKeys) {
				var i2 = _g4++;
				var x1 = stroke + keyWidth * i2;
				var focused = touching && i2 == whiteIndex;
				if(focused == null) {
					focused = false;
				}
				_gthis.c2d.fillStyle = "rgba(" + (0. | 0) + "," + (0. | 0) + "," + (0. | 0) + "," + 1.0 + ")";
				_gthis.c2d.fillRect(x1,0,keyWidth,height);
				if(focused) {
					_gthis.c2d.fillStyle = "rgba(" + (255.0 | 0) + "," + (153. | 0) + "," + (153. | 0) + "," + 1.0 + ")";
				} else {
					_gthis.c2d.fillStyle = "rgba(" + (255.0 | 0) + "," + (255.0 | 0) + "," + (255.0 | 0) + "," + 1.0 + ")";
				}
				_gthis.c2d.fillRect(x1,stroke,keyWidth - stroke,height - stroke * 2);
				if(!focused) {
					var shadowH = keyWidth * 0.6;
					_gthis.c2d.fillStyle = "rgba(" + (204. | 0) + "," + (204. | 0) + "," + (204. | 0) + "," + 1.0 + ")";
					_gthis.c2d.fillRect(x1,height - shadowH + stroke,keyWidth - stroke,shadowH - stroke * 2);
				}
				if(i2 == 0) {
					_gthis.c2d.fillStyle = "rgba(" + (0. | 0) + "," + (0. | 0) + "," + (0. | 0) + "," + 1.0 + ")";
					_gthis.c2d.textAlign = "center";
					var x2 = stroke + keyWidth * (i2 + 0.5);
					var y = height * 0.7 + (touching && i2 == whiteIndex ? keyWidth * 0.2 : 0.0);
					var scale = _gthis.view.scale;
					if(scale == null) {
						scale = 1.0;
					}
					if(scale != 1.0) {
						_gthis.c2d.save();
						_gthis.c2d.translate(x2,y);
						_gthis.c2d.scale(scale,scale);
						_gthis.c2d.fillText(text,0,0);
						_gthis.c2d.restore();
					} else {
						_gthis.c2d.fillText(text,x2,y);
					}
				}
			}
			var _g6 = 0;
			var _g7 = numKeys - 1;
			while(_g6 < _g7) {
				var i3 = _g6++;
				if(blackKeyExists[i3 % blackKeyExists.length]) {
					var x3 = stroke + keyWidth * (i3 + 1) - keyWidth * 0.6 * 0.5;
					var w = keyWidth * 0.6;
					var h = height * 0.5;
					var focused1 = touching && i3 == blackIndex;
					if(focused1 == null) {
						focused1 = false;
					}
					_gthis.c2d.fillStyle = "rgba(" + (0. | 0) + "," + (0. | 0) + "," + (0. | 0) + "," + 1.0 + ")";
					_gthis.c2d.fillRect(x3,0,w,h);
					if(focused1) {
						_gthis.c2d.fillStyle = "rgba(" + (153. | 0) + "," + (0. | 0) + "," + (0. | 0) + "," + 1.0 + ")";
						_gthis.c2d.fillRect(x3 + stroke,stroke,w - stroke * 2,h - stroke * 2);
					}
					if(!focused1) {
						var shadowH1 = keyWidth * 0.5;
						_gthis.c2d.fillStyle = "rgba(" + (102. | 0) + "," + (102. | 0) + "," + (102. | 0) + "," + 1.0 + ")";
						_gthis.c2d.fillRect(x3 + stroke,h - shadowH1 + stroke,w - stroke * 2,shadowH1 - stroke * 2);
					}
					var dx1 = x3 + w * 0.5 - touchCanvasX;
				}
			}
			var keyIndex = 0;
			var _g8 = 0;
			while(_g8 < numKeys) {
				var i4 = _g8++;
				if(whiteIndex == i4) {
					result = keyIndex;
					return;
				}
				++keyIndex;
				if(blackKeyExists[i4 % blackKeyExists.length]) {
					if(blackIndex == i4) {
						result = keyIndex;
						return;
					}
					++keyIndex;
				}
			}
			return;
		})();
		this.c2d.restore();
		return result;
	}
	,renderMenu: function(menu,time,x,y) {
		var _gthis = this;
		this.c2d.fillStyle = "rgba(" + (255.0 | 0) + "," + (255.0 | 0) + "," + (255.0 | 0) + "," + 0.9 + ")";
		this.c2d.fillRect(0,0,this.canvas.width,this.canvas.height);
		if(time < 1) {
			x = 0;
			y = 0;
		} else {
			x -= this.view.centerX;
			y -= this.view.centerY;
			y += this.canvas.height / this.view.scale * this.canvasCenterHeightRatio;
		}
		var t = time > 1 ? 1 : time;
		t = 1 - t;
		t = t * t * t * t;
		t = 1 - t;
		var res;
		var x1 = this.canvas.width * 0.5;
		this.c2d.save();
		this.c2d.translate(x1,0);
		_gthis.c2d.scale(_gthis.view.scale,_gthis.view.scale * t);
		res = _gthis.drawMenu(menu,x,y);
		this.c2d.restore();
		return res;
	}
	,drawMenu: function(menu,mx,my) {
		this.c2d.fillStyle = "rgba(" + (0. | 0) + "," + (0. | 0) + "," + (0. | 0) + "," + 1.0 + ")";
		this.c2d.strokeStyle = "rgba(" + (0. | 0) + "," + (0. | 0) + "," + (0. | 0) + "," + 1.0 + ")";
		var y = this.canvas.height / this.view.scale * 0.15;
		this.c2d.textAlign = "center";
		this.c2d.lineWidth = 0.5;
		var s = menu.title;
		this.c2d.save();
		this.c2d.translate(0,y);
		this.c2d.scale(2.0,2.0);
		this.c2d.strokeText(s,0,0);
		this.c2d.restore();
		y += 24;
		this.c2d.textAlign = "left";
		var result = -1;
		var idx = 0;
		var _g = 0;
		var _g1 = menu.items.length;
		while(_g < _g1) {
			var row = menu.items[_g++];
			if(row.length == 0) {
				y += 6;
				continue;
			}
			var width = 250 / row.length;
			var colX = -125.0;
			var _g2 = 0;
			while(_g2 < row.length) {
				var item = row[_g2];
				++_g2;
				if(item != null) {
					this.c2d.fillStyle = "rgba(" + (0. | 0) + "," + (0. | 0) + "," + (0. | 0) + "," + 1.0 + ")";
					if(mx > colX && mx < colX + width && my > y - 10 && my < y + 10) {
						this.c2d.fillStyle = "rgba(" + (153. | 0) + "," + (0. | 0) + "," + (0. | 0) + "," + 1.0 + ")";
						this.c2d.strokeStyle = "rgba(" + (153. | 0) + "," + (0. | 0) + "," + (0. | 0) + "," + 1.0 + ")";
						result = idx;
						this.c2d.lineWidth = 1;
						this.c2d.beginPath();
						this.c2d.moveTo(colX,y + 10);
						this.c2d.lineTo(colX + width,y + 10);
						this.c2d.stroke();
					}
					this.c2d.beginPath();
					this.c2d.arc(colX + 10,y,3,0,6.2831853071795862);
					this.c2d.fill();
					this.c2d.save();
					this.c2d.translate(colX + 20,y);
					this.c2d.scale(1.2,1.2);
					this.c2d.fillText(item,0,0);
					this.c2d.restore();
				}
				colX += width;
				++idx;
			}
			y += 20;
		}
		return result;
	}
	,createLabelForSocket: function(s,name) {
		var c = window.document.createElement("canvas");
		c.width = 120;
		c.height = 30;
		var c2d = c.getContext("2d",null);
		c2d.textAlign = "left";
		c2d.font = "bold 30px \"Courier New\"";
		c2d.fillStyle = "rgb(0,0,0)";
		c2d.strokeStyle = "rgb(255,255,255)";
		c2d.lineWidth = 8;
		var x = c2d.lineWidth;
		c2d.strokeText(name,x,c.height * 0.5);
		c2d.fillText(name,x,c.height * 0.6);
		var c1 = window.document.createElement("canvas");
		c1.width = 120;
		c1.height = 30;
		var c2d1 = c1.getContext("2d",null);
		c2d1.textAlign = "right";
		c2d1.font = "bold 30px \"Courier New\"";
		c2d1.fillStyle = "rgb(0,0,0)";
		c2d1.strokeStyle = "rgb(255,255,255)";
		c2d1.lineWidth = 8;
		var x1 = c1.width - c2d1.lineWidth;
		c2d1.strokeText(name,x1,c1.height * 0.5);
		c2d1.fillText(name,x1,c1.height * 0.6);
		s.phys.labels = [c,c1];
		s.phys.labelText = name;
	}
	,drawGraph: function(graph) {
		this.waveData.length = 0;
		graph.listener.onWaveDataRequest(this.waveData);
		this.drawCables(graph);
		var _g = 0;
		var _g1 = graph.nodes;
		while(_g < _g1.length) this.drawNode(_g1[_g++]);
		var _g2 = 0;
		var _g3 = graph.nodes;
		while(_g2 < _g3.length) {
			var n = _g3[_g2];
			++_g2;
			var _g21 = 0;
			var _g31 = n.sockets;
			while(_g21 < _g31.length) this.drawSocket(n,_g31[_g21++]);
		}
	}
	,drawCables: function(graph1) {
		var _g = 0;
		var _g1 = graph1.vertices;
		while(_g < _g1.length) _g1[_g++].tmpValForRendering = 0;
		this.c2d.lineWidth = 1;
		this.c2d.strokeStyle = "rgba(" + (0. | 0) + "," + (0. | 0) + "," + (0. | 0) + "," + 1.0 + ")";
		this.c2d.beginPath();
		var visited = [];
		var _g2 = 0;
		var _g3 = graph1.nodes;
		while(_g2 < _g3.length) {
			var _g21 = 0;
			var _g31 = _g3[_g2++].sockets;
			while(_g21 < _g31.length) {
				var s = _g31[_g21];
				++_g21;
				if(graph_SocketTypeTool.io(s.type) != true) {
					continue;
				}
				var _g22 = 0;
				var _g32 = s.connections;
				while(_g22 < _g32.length) {
					var c = _g32[_g22];
					++_g22;
					var s2 = c.to;
					var fromV = s.phys.vertex;
					var toV = s2.phys.vertex;
					visited.length = 0;
					var x1 = fromV.point.x;
					var y1 = fromV.point.y;
					var dx = toV.point.x - x1;
					var dy = toV.point.y - y1;
					var len = Math.sqrt(dx * dx + dy * dy);
					var invLen = len == 0 ? 0 : 1 / len;
					var tx = -dy * invLen;
					var ty = dx * invLen;
					var pv = fromV;
					var _this = c.firstEdge;
					var v = fromV != _this.v1 ? _this.v1 : _this.v2;
					var ng = false;
					while(v != toV) {
						if(v.edges.length != 2) {
							throw new js__$Boot_HaxeError("invalid topology: " + v.edges.length);
						}
						visited.push(v);
						var deviation = (v.point.x - x1) * tx + (v.point.y - y1) * ty;
						if(deviation * deviation > 0.010000000000000002) {
							ng = true;
							break;
						}
						var _this1 = v.edges[0];
						var v1 = v != _this1.v1 ? _this1.v1 : _this1.v2;
						var _this2 = v.edges[1];
						var nv = v1 != pv ? v1 : v != _this2.v1 ? _this2.v1 : _this2.v2;
						pv = v;
						v = nv;
					}
					if(!ng) {
						var _g23 = 0;
						while(_g23 < visited.length) visited[_g23++].tmpValForRendering = 1;
						var sp = s.phys;
						var s2p = s2.phys;
						this.c2d.moveTo(sp.vertex.point.x,sp.vertex.point.y);
						this.c2d.lineTo(s2p.vertex.point.x,s2p.vertex.point.y);
					}
				}
			}
		}
		this.c2d.stroke();
		this.c2d.strokeStyle = "rgba(" + (0. | 0) + "," + (0. | 0) + "," + (0. | 0) + "," + 1.0 + ")";
		this.c2d.beginPath();
		var _g4 = 0;
		var _g5 = graph1.edges;
		while(_g4 < _g5.length) {
			var e = _g5[_g4];
			++_g4;
			if(e.v1.tmpValForRendering == 1 || e.v2.tmpValForRendering == 1) {
				continue;
			}
			if(e.v1.type._hx_index != 0 && e.v2.type._hx_index != 0) {
				this.c2d.moveTo(e.v1.point.x,e.v1.point.y);
				this.c2d.lineTo(e.v2.point.x,e.v2.point.y);
			}
		}
		this.c2d.stroke();
	}
	,drawOutputWave: function(x,y,radius) {
		var _gthis = this;
		if(this.waveData.length == 0) {
			this.c2d.strokeStyle = "rgba(" + (178.5 | 0) + "," + (178.5 | 0) + "," + (178.5 | 0) + "," + 1.0 + ")";
		} else {
			this.c2d.strokeStyle = "rgba(" + (0. | 0) + "," + (0. | 0) + "," + (0. | 0) + "," + 1.0 + ")";
		}
		this.c2d.beginPath();
		this.c2d.moveTo(x - radius,y);
		if(this.waveData.length > 0) {
			var _g = 0;
			while(_g < 129) {
				var t = _g++ / 128 * 2 - 1;
				var maxAmp = Math.min(0.6,Math.sqrt(1 - t * t));
				var len = _gthis.waveData.length;
				var indexF = (t + 1) * 0.5 * len;
				var index = Math.floor(indexF);
				var index2 = index + 1;
				var fract = indexF - index;
				var max = len - 1;
				index = index < 0 ? 0 : index > max ? max : index;
				var max1 = len - 1;
				index2 = index2 < 0 ? 0 : index2 > max1 ? max1 : index2;
				var v1 = _gthis.waveData[index];
				var amp = (v1 + (_gthis.waveData[index2] - v1) * fract) * 0.6;
				var min = -maxAmp;
				amp = amp < min ? min : amp > maxAmp ? maxAmp : amp;
				this.c2d.lineTo(x + t * radius,y - amp * radius);
				this.c2d.moveTo(x + t * radius,y - amp * radius);
			}
		}
		this.c2d.lineTo(x + radius,y);
		this.c2d.stroke();
	}
	,drawNode: function(node) {
		var isDestination = node.setting.role._hx_index == 2;
		this.c2d.lineWidth = 1;
		var np = node.phys;
		var x = np.vertex.point.x;
		var y = np.vertex.point.y;
		if(isDestination) {
			this.drawOutputWave(x,y,np.radius);
		}
		this.c2d.strokeStyle = "rgba(" + (0. | 0) + "," + (0. | 0) + "," + (0. | 0) + "," + 1.0 + ")";
		this.c2d.fillStyle = "rgba(" + (0. | 0) + "," + (0. | 0) + "," + (0. | 0) + "," + 1.0 + ")";
		var r = np.radius;
		this.c2d.beginPath();
		this.c2d.arc(x,y,r,0,6.2831853071795862);
		this.c2d.stroke();
		if(node.selected) {
			node.selectingCount++;
			var t = node.selectingCount % 40 / 40;
			var strokeA = 1 - t;
			this.c2d.lineWidth = 1 + (1 - strokeA) * 5 * (node.phys.radius / 12);
			var a = strokeA;
			if(strokeA == null) {
				a = 1.0;
			}
			this.c2d.strokeStyle = "rgba(" + (0. | 0) + "," + (0. | 0) + "," + (0. | 0) + "," + a + ")";
			var r1 = np.radius * (1 + (1 - (1 - t) * (1 - t)) * 0.5);
			this.c2d.beginPath();
			this.c2d.arc(x,y,r1,0,6.2831853071795862);
			this.c2d.stroke();
			this.c2d.lineWidth = 1;
		}
		var _g1 = node.type;
		if(_g1._hx_index == 3) {
			if(_g1.io) {
				var r2 = np.radius * 0.8;
				this.c2d.beginPath();
				this.c2d.arc(x,y,r2,0,6.2831853071795862);
				this.c2d.stroke();
			} else {
				this.c2d.lineWidth = np.radius * 0.19999999999999996;
				var r3 = np.radius * 1.8 * 0.5;
				this.c2d.beginPath();
				this.c2d.arc(x,y,r3,0,6.2831853071795862);
				this.c2d.stroke();
				this.c2d.lineWidth = 1;
			}
		}
		var textY = isDestination ? y - np.radius * 0.75 : y;
		this.c2d.textAlign = "center";
		var _g3 = node.setting.role;
		if(_g3._hx_index == 7) {
			this.c2d.fillText(Std.string(_g3.num.get_value()),x,textY);
		} else {
			this.c2d.fillText(node.setting.name,x,textY);
		}
	}
	,drawSocket: function(node,socket) {
		var _gthis = this;
		var sp = socket.phys;
		sp.computeDrawingPos();
		this.c2d.strokeStyle = "rgba(" + (0. | 0) + "," + (0. | 0) + "," + (0. | 0) + "," + 1.0 + ")";
		var x = sp.xForDrawing;
		var y = sp.yForDrawing;
		var r = sp.radius;
		var mode = graph_SocketTypeTool.io(socket.type) ? 2 : 3;
		this.c2d.beginPath();
		this.c2d.arc(x,y,r,0,6.2831853071795862);
		if((mode & 1) != 0) {
			this.c2d.fill();
		}
		if((mode & 2) != 0) {
			this.c2d.stroke();
		}
		var name;
		var _g1 = socket.type;
		switch(_g1._hx_index) {
		case 0:
			name = "";
			break;
		case 1:
			name = _g1.name;
			break;
		case 2:
			name = _g1.boundary.setting.name;
			break;
		}
		if(name != "") {
			if(sp.labels == null || sp.labelText != name) {
				this.createLabelForSocket(socket,name);
			}
			var l1 = sp.labels[0];
			var l2 = sp.labels[1];
			var angle = Math.atan2(sp.normalY,sp.normalX);
			var np = node.phys;
			var x1 = np.vertex.point.x;
			var y1 = np.vertex.point.y;
			this.c2d.save();
			this.c2d.strokeStyle = "rgba(" + (255.0 | 0) + "," + (255.0 | 0) + "," + (255.0 | 0) + "," + 1.0 + ")";
			this.c2d.translate(x1,y1);
			this.c2d.rotate(angle);
			this.c2d.translate(np.radius + sp.radius * 2 - 1,0);
			this.c2d.scale(0.25,0.25);
			if(sp.normalX < 0) {
				this.c2d.save();
				this.c2d.rotate(3.141592653589793);
				_gthis.c2d.drawImage(l2,-l1.width,-l1.height * 0.5);
				this.c2d.restore();
			} else {
				this.c2d.drawImage(l1,0,-l1.height * 0.5);
			}
			this.c2d.restore();
		}
	}
	,worldX: function(canvasX) {
		return (canvasX - this.canvas.width * 0.5) / this.view.scale + this.view.centerX;
	}
	,worldY: function(canvasY) {
		return (canvasY - this.canvas.height * this.canvasCenterHeightRatio) / this.view.scale + this.view.centerY;
	}
	,canvasX: function(worldX) {
		return (worldX - this.view.centerX) * this.view.scale + this.canvas.width * 0.5;
	}
	,canvasY: function(worldY) {
		return (worldY - this.view.centerY) * this.view.scale + this.canvas.height * this.canvasCenterHeightRatio;
	}
	,fill: function(r,g,b,a) {
		if(a == null) {
			a = 1.0;
		}
		this.c2d.fillStyle = "rgba(" + (r * 255.0 | 0) + "," + (g * 255.0 | 0) + "," + (b * 255.0 | 0) + "," + a + ")";
	}
	,stroke: function(r,g,b,a) {
		if(a == null) {
			a = 1.0;
		}
		this.c2d.strokeStyle = "rgba(" + (r * 255.0 | 0) + "," + (g * 255.0 | 0) + "," + (b * 255.0 | 0) + "," + a + ")";
	}
	,__class__: render_Renderer
};
var render_View = function() {
	this.centerX = 0;
	this.centerY = 0;
	this.scale = 2;
};
render_View.__name__ = true;
render_View.prototype = {
	__class__: render_View
};
var synth_NodeRoleTools = function() { };
synth_NodeRoleTools.__name__ = true;
synth_NodeRoleTools.copy = function(role) {
	switch(role._hx_index) {
	case 6:
		var _g1 = role.env;
		return synth_NodeRole.Envelope(new synth_EnvelopeData(_g1.a,_g1.d,_g1.s,_g1.r));
	case 7:
		return synth_NodeRole.Number(new synth_NumberData(role.num.get_value()));
	default:
		return role;
	}
};
function $getIterator(o) { if( o instanceof Array ) return HxOverrides.iter(o); else return o.iterator(); }
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $global.$haxeUID++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = m.bind(o); o.hx__closures__[m.__id__] = f; } return f; }
$global.$haxeUID |= 0;
if( String.fromCodePoint == null ) String.fromCodePoint = function(c) { return c < 0x10000 ? String.fromCharCode(c) : String.fromCharCode((c>>10)+0xD7C0)+String.fromCharCode((c&0x3FF)+0xDC00); }
String.prototype.__class__ = String;
String.__name__ = true;
Array.__name__ = true;
var Int = { };
var Dynamic = { };
var Float = Number;
var Bool = Boolean;
var Class = { };
var Enum = { };
haxe_ds_ObjectMap.count = 0;
Object.defineProperty(js__$Boot_HaxeError.prototype,"message",{ get : function() {
	return String(this.val);
}});
js_Boot.__toStr = ({ }).toString;
app_NodeList.FREQUENCY = new app_NodeInfo("input frequency","f",graph_NodeType.Normal(false,true),synth_NodeRole.Frequency,[],[]);
app_NodeList.OSCILLATOR = new app_NodeInfo("oscillator","sin",graph_NodeType.Normal(false,true),synth_NodeRole.Oscillator("sin"),["freq","detune"],[]);
app_NodeList.OUTPUT = new app_NodeInfo("output","out",graph_NodeType.Normal(true,false),synth_NodeRole.Destination,[],[]);
app_NodeList.DELAY = new app_NodeInfo("delay","del",graph_NodeType.Normal(true,true),synth_NodeRole.Delay,["time"],[]);
app_NodeList.FILTER = new app_NodeInfo("filter","LPF",graph_NodeType.Normal(true,true),synth_NodeRole.Filter("lp"),["freq","Q","gain"],[]);
app_NodeList.COMPRESSOR = new app_NodeInfo("compressor","cmp",graph_NodeType.Normal(true,true),synth_NodeRole.Compressor,[],[]);
app_NodeList.ENVELOPE = new app_NodeInfo("envelope","env",graph_NodeType.Normal(false,true),synth_NodeRole.Envelope(new synth_EnvelopeData(0.05,0.1,0.8,0.1)),[],[]);
app_NodeList.NUMBER = new app_NodeInfo("number","",graph_NodeType.Normal(false,true),synth_NodeRole.Number(new synth_NumberData(0.0)),[],[]);
app_NodeList.ADD = new app_NodeInfo("addition","+",graph_NodeType.Small,synth_NodeRole.BinOp(0),[],[]);
app_NodeList.MULT = new app_NodeInfo("multiplication","×",graph_NodeType.Small,synth_NodeRole.BinOp(1),[],[]);
app_NodeList.DUPL = new app_NodeInfo("duplication","",graph_NodeType.Small,synth_NodeRole.Dupl,[],[]);
app_UISetting.pixelRatio = window.devicePixelRatio | 0;
app_UISetting.dragBeginThreshold = app_UISetting.pixelRatio * 10;
app_UISetting.tapErrorThreshold = app_UISetting.pixelRatio * 20;
app_UISetting.longPressTimeThreshold = 20;
app_AudioNodeTools.mapN = new WeakMap();
app_AudioNodeTools.mapP = new WeakMap();
graph_Graph.CABLE_LENGTH = 4.0;
graph_Graph.MARGIN = 1.0;
graph_Graph.CABLE_MASS = 0.5;
graph_Graph.dfsCount = 1;
graph_Node.idCount = 0;
graph_NodePhys.DEFAULT_RADIUS = 12;
graph_NodePhys.SMALL_NODE_INV_MASS = 0;
graph_NodePhys.NORMAL_NODE_INV_MASS = 0;
graph_Socket.idCount = 0;
graph_SocketPhys.RADIUS_SMALL = 2.0;
graph_SocketPhys.RADIUS_LARGE = 4.0;
graph_SocketPhys.INV_MASS = 0.2;
graph_Vertex.MAX_LIFE = 60;
graph_Vertex.CABLE_DAMPING = 0.95;
graph_Vertex.NODE_DAMPING = 0.8;
graph_Vertex.idCount = 0;
pot_util_Timer.MIN_SLEEP_TIME = 5;
render_Renderer.PI = 3.141592653589793;
render_Renderer.TWO_PI = 6.2831853071795862;
render_Renderer.HALF_PI = 1.5707963267948966;
render_Renderer.FILL = 1;
render_Renderer.STROKE = 2;
app_Main.main();
})(typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this);
